<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>attack-workbench-frontend documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">attack-workbench-frontend documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">













<ol class="breadcrumb">
  <li>Interfaces</li>
  <li
  >
  FilterValue</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/app/components/stix/stix-list/stix-list.component.ts</code>
        </p>




        <section>
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#disabled" 
>
                                            disabled
                                        </a>
                                </li>
                                <li>
                                        <a href="#label" 
>
                                            label
                                        </a>
                                </li>
                                <li>
                                        <a href="#value" 
>
                                            value
                                        </a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section>
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="disabled"></a>
                                        <span class="name "><b>disabled</b>
                                            <a href="#disabled">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>disabled:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="label"></a>
                                        <span class="name "><b>label</b>
                                            <a href="#label">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>label:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="value"></a>
                                        <span class="name "><b>value</b>
                                            <a href="#value">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>value:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { Component, OnInit, Input, ViewEncapsulation, ViewChild, AfterViewInit, ElementRef, EventEmitter, Output, OnDestroy } from &#x27;@angular/core&#x27;;
import { animate, style, transition, trigger } from &#x27;@angular/animations&#x27;;
import { MatPaginator } from &#x27;@angular/material/paginator&#x27;;
import { SelectionModel } from &#x27;@angular/cdk/collections&#x27;;
import { MatDialog } from &#x27;@angular/material/dialog&#x27;;
import { Router } from &#x27;@angular/router&#x27;;

import { fromEvent, Observable, of, Subscription } from &#x27;rxjs&#x27;;
import { debounceTime, distinctUntilChanged, filter, tap } from &#x27;rxjs/operators&#x27;;

import { StixObject } from &#x27;src/app/classes/stix/stix-object&#x27;;
import { StixDialogComponent } from &#x27;src/app/views/stix/stix-dialog/stix-dialog.component&#x27;;
import { Paginated, RestApiConnectorService } from &#x27;src/app/services/connectors/rest-api/rest-api-connector.service&#x27;;
import { AuthenticationService } from &#x27;src/app/services/connectors/authentication/authentication.service&#x27;;

@Component({
    selector: &#x27;app-stix-list&#x27;,
    templateUrl: &#x27;./stix-list.component.html&#x27;,
    styleUrls: [&#x27;./stix-list.component.scss&#x27;],
    encapsulation: ViewEncapsulation.None,
    animations: [
        trigger(&quot;detailExpand&quot;, [
            transition(&quot;:enter&quot;, [
                style({ height: &#x27;0px&#x27;, minHeight: &#x27;0px&#x27;}),
                animate(&quot;100ms cubic-bezier(0.4, 0.0, 0.2, 1)&quot;, style({height: &#x27;*&#x27;}))
            ]),
            transition(&#x27;:leave&#x27;, [
                animate(&#x27;100ms cubic-bezier(0.4, 0.0, 0.2, 1)&#x27;, style({ height: &#x27;0px&#x27;, minHeight: &#x27;0px&#x27; }))
            ])
        ]),
        trigger(&quot;fadeIn&quot;, [
            transition(&quot;:enter&quot;, [
                style({ opacity: 0 }),
                animate(&quot;500ms cubic-bezier(0.4, 0.0, 0.2, 1)&quot;, style({opacity: &#x27;1&#x27;}))
            ])
        ])
    ]
})
export class StixListComponent implements OnInit, AfterViewInit, OnDestroy {
    @Input() public config: StixListConfig &#x3D; {};

    @Output() public onRowAction &#x3D; new EventEmitter&lt;string&gt;();
    @Output() public onSelect &#x3D; new EventEmitter&lt;StixObject&gt;();
    @Output() public refresh &#x3D; new EventEmitter();

    @ViewChild(MatPaginator) paginator: MatPaginator;
    @ViewChild(&#x27;search&#x27;) search: ElementRef;

    // search query
    public searchQuery: string &#x3D; &quot;&quot;;
    private searchSubscription: Subscription;

    // objects to render
    public objects$: Observable&lt;StixObject[]&gt;;
    public data$: Observable&lt;Paginated&lt;StixObject&gt;&gt;;
    public totalObjectCount: number &#x3D; 0;

    // view mode
    public mode: string &#x3D; &quot;cards&quot;;

    // options provided to the user for grouping and filtering
    public filterOptions: FilterGroup[] &#x3D; [];

    // current grouping and filtering selections
    public filter: string[] &#x3D; [];
    public groupBy: string[] &#x3D; [];

    // TABLE STUFF
    public tableColumns: string[] &#x3D; [];
    public tableColumns_controls: string[]; //including select behavior
    public tableColumns_settings: Map&lt;string, any&gt; &#x3D; new Map&lt;string, any&gt;(); // property to display for each displayProperty
    public tableDetail: any[];
    public expandedElement: StixObject | null;

    // Selection stuff
    public selection: SelectionModel&lt;string&gt;;

    // Type map for redirections
    private typeMap &#x3D; {
        &quot;x-mitre-collection&quot;: &quot;collection&quot;,
        &quot;attack-pattern&quot;: &quot;technique&quot;,
        &quot;malware&quot;: &quot;software&quot;,
        &quot;tool&quot;: &quot;software&quot;,
        &quot;intrusion-set&quot;: &quot;group&quot;,
        &quot;campaign&quot;: &quot;campaign&quot;,
        &quot;course-of-action&quot;: &quot;mitigation&quot;,
        &quot;x-mitre-matrix&quot;: &quot;matrix&quot;,
        &quot;x-mitre-tactic&quot;: &quot;tactic&quot;,
        &quot;relationship&quot;: &quot;relationship&quot;
    }

    // all possible each type of filter/groupBy
    private platformSubscription: Subscription;
    private platformMap: Map&lt;string, Map&lt;string, string[]&gt;&gt; &#x3D; new Map();
    private domains: FilterValue[] &#x3D; [
        {&quot;value&quot;: &quot;domain.enterprise-attack&quot;, &quot;label&quot;: &quot;enterprise&quot;, &quot;disabled&quot;: false},
        {&quot;value&quot;: &quot;domain.mobile-attack&quot;, &quot;label&quot;: &quot;mobile&quot;, &quot;disabled&quot;: false},
        {&quot;value&quot;: &quot;domain.ics-attack&quot;, &quot;label&quot;: &quot;ics&quot;, &quot;disabled&quot;: false}
    ]
    private statuses: FilterValue[] &#x3D; [
        {&quot;value&quot;: &quot;status.work-in-progress&quot;, &quot;label&quot;: &quot;show only work in progress&quot;, &quot;disabled&quot;: false},
        {&quot;value&quot;: &quot;status.awaiting-review&quot;, &quot;label&quot;: &quot;show only awaiting review&quot;, &quot;disabled&quot;: false},
        {&quot;value&quot;: &quot;status.reviewed&quot;, &quot;label&quot;: &quot;show only reviewed&quot;, &quot;disabled&quot;: false}
    ]
    private states: FilterValue[] &#x3D; [
        {&quot;value&quot;: &quot;state.deprecated&quot;, &quot;label&quot;: &quot;include deprecated&quot;, &quot;disabled&quot;: false},
        {&quot;value&quot;: &quot;state.revoked&quot;, &quot;label&quot;: &quot;include revoked&quot;, &quot;disabled&quot;: false}
    ]

    constructor(public dialog: MatDialog, 
                private restAPIConnectorService: RestApiConnectorService, 
                private router: Router, 
                private authenticationService: AuthenticationService) { }

    ngOnInit(): void {
        // build query options for platforms
        this.platformSubscription &#x3D; this.restAPIConnectorService.getAllAllowedValues().subscribe({
            next: (data) &#x3D;&gt; {
                for (let values of data) {
                    // setup domain map (domainName-&gt;platforms)
                    let domainMap: Map&lt;string, string[]&gt; &#x3D; new Map();
                    if (values.properties) {
                        // extract domain-&gt;platforms properties from allowedValues structure
                        let properties &#x3D; values.properties.find(p &#x3D;&gt; p.propertyName &#x3D;&#x3D; &#x27;x_mitre_platforms&#x27;);
                        if (properties &amp;&amp; properties.domains) {
                            properties.domains.forEach(domain &#x3D;&gt; {
                                domainMap.set(domain.domainName, domain.allowedValues);
                            });
                        }
                    }
                    // set attackType-&gt;domainMap
                    this.platformMap.set(values[&quot;objectType&quot;], domainMap);
                }
            },
            complete: () &#x3D;&gt; {
                // build the stix list table
                this.buildTable();
                this.setUpControls();
                // get objects from backend if data is not from config
                if (!(&quot;stixObjects&quot; in this.config)) {
                    this.applyControls();
                }
            }
        });
    }

    ngAfterViewInit() {
        // set up listener to search input
        if (this.config.type &amp;&amp; this.config.type !&#x3D; &quot;relationship&quot;) {
            this.searchSubscription &#x3D; fromEvent(this.search.nativeElement, &#x27;keyup&#x27;).pipe(
                filter(Boolean),
                debounceTime(250),
                distinctUntilChanged(),
                tap(_ &#x3D;&gt; { 
                    if (this.paginator) this.paginator.pageIndex &#x3D; 0;
                    this.applyControls();
                })
            ).subscribe()
        }
    }

    /**
     * Build the stix list table to display
     */
    private buildTable(): void {
        // filter options
        this.filterOptions &#x3D; []
        if (!(&#x27;showFilters&#x27; in this.config)) this.config.showFilters &#x3D; true;

        // parse the config
        let sticky_allowed &#x3D; !(this.config.rowAction &amp;&amp; this.config.rowAction.position &#x3D;&#x3D; &quot;start&quot;);
        if (&quot;type&quot; in this.config) { 
            // set columns according to type
            switch(this.config.type.replace(/_/g, &#x27;-&#x27;)) {
                case &quot;collection&quot;:
                case &quot;collection-created&quot;:
                    this.addColumn(&quot;name&quot;, &quot;name&quot;, &quot;plain&quot;, sticky_allowed, [&quot;name&quot;]);
                    this.addColumn(&quot;released?&quot;, &quot;release&quot;, &quot;plain&quot;, null, [&quot;text-label&quot;]);
                    this.addVersionsAndDatesColumns();
                    this.tableDetail &#x3D; [{
                        &quot;field&quot;: &quot;description&quot;,
                        &quot;display&quot;: &quot;descriptive&quot;
                    }]
                    break;
                case &quot;collection-imported&quot;:
                    this.addColumn(&quot;name&quot;, &quot;name&quot;, &quot;plain&quot;, sticky_allowed, [&quot;name&quot;]);
                    this.addColumn(&quot;version&quot;, &quot;version&quot;, &quot;version&quot;);
                    this.addColumn(&quot;imported&quot;, &quot;imported&quot;, &quot;timestamp&quot;);
                    this.addColumn(&quot;modified&quot;, &quot;modified&quot;, &quot;timestamp&quot;);
                    this.tableDetail &#x3D; [{
                        &quot;field&quot;: &quot;description&quot;,
                        &quot;display&quot;: &quot;descriptive&quot;
                    }]
                    break;
                case &quot;mitigation&quot;:
                case &quot;tactic&quot;:
                    this.addColumn(&quot;&quot;, &quot;workflow&quot;, &quot;icon&quot;);
                    this.addColumn(&quot;&quot;, &quot;state&quot;, &quot;icon&quot;);
                    this.addColumn(&quot;ID&quot;, &quot;attackID&quot;, &quot;plain&quot;, false);
                    this.addColumn(&quot;name&quot;, &quot;name&quot;, &quot;plain&quot;, sticky_allowed, [&quot;name&quot;]);
                    this.addColumn(&quot;domain&quot;, &quot;domains&quot;, &quot;list&quot;);
                    this.addVersionsAndDatesColumns();
                    this.tableDetail &#x3D; [{
                        &quot;field&quot;: &quot;description&quot;,
                        &quot;display&quot;: &quot;descriptive&quot;
                    }]
                    break;
                case &quot;matrix&quot;:
                    this.addColumn(&quot;&quot;, &quot;workflow&quot;, &quot;icon&quot;);
                    this.addColumn(&quot;&quot;, &quot;state&quot;, &quot;icon&quot;);
                    this.addColumn(&quot;name&quot;, &quot;name&quot;, &quot;plain&quot;, sticky_allowed, [&quot;name&quot;]);
                    this.addVersionsAndDatesColumns();
                    this.tableDetail &#x3D; [{
                        &quot;field&quot;: &quot;description&quot;,
                        &quot;display&quot;: &quot;descriptive&quot;
                    }]
                    break;
                case &quot;campaign&quot;:
                    this.addColumn(&quot;&quot;, &quot;workflow&quot;, &quot;icon&quot;);
                    this.addColumn(&quot;&quot;, &quot;state&quot;, &quot;icon&quot;);
                    this.addColumn(&quot;ID&quot;, &quot;attackID&quot;, &quot;plain&quot;, false);
                    this.addColumn(&quot;name&quot;, &quot;name&quot;, &quot;plain&quot;, sticky_allowed, [&quot;name&quot;]);
                    this.addVersionsAndDatesColumns();
                    this.tableDetail &#x3D; [{
                        &quot;field&quot;: &quot;description&quot;,
                        &quot;display&quot;: &quot;descriptive&quot;
                    }];
                    break;
                case &quot;group&quot;:
                    this.addColumn(&quot;&quot;, &quot;workflow&quot;, &quot;icon&quot;);
                    this.addColumn(&quot;&quot;, &quot;state&quot;, &quot;icon&quot;);
                    this.addColumn(&quot;ID&quot;, &quot;attackID&quot;, &quot;plain&quot;, false);
                    this.addColumn(&quot;name&quot;, &quot;name&quot;, &quot;plain&quot;, sticky_allowed, [&quot;name&quot;]);
                    this.addColumn(&quot;associated groups&quot;, &quot;aliases&quot;, &quot;list&quot;);
                    this.addVersionsAndDatesColumns();
                    this.tableDetail &#x3D; [{
                        &quot;field&quot;: &quot;description&quot;,
                        &quot;display&quot;: &quot;descriptive&quot;
                    }]
                    break;
                case &quot;software&quot;:
                    this.addColumn(&quot;&quot;, &quot;workflow&quot;, &quot;icon&quot;);
                    this.addColumn(&quot;&quot;, &quot;state&quot;, &quot;icon&quot;);
                    this.addColumn(&quot;ID&quot;, &quot;attackID&quot;, &quot;plain&quot;, false);
                    this.addColumn(&quot;name&quot;, &quot;name&quot;, &quot;plain&quot;, sticky_allowed, [&quot;name&quot;]);
                    this.addColumn(&quot;type&quot;, &quot;type&quot;, &quot;plain&quot;);
                    this.addColumn(&quot;domain&quot;, &quot;domains&quot;, &quot;list&quot;);
                    this.addVersionsAndDatesColumns();
                    this.tableDetail &#x3D; [{
                        &quot;field&quot;: &quot;description&quot;,
                        &quot;display&quot;: &quot;descriptive&quot;
                    }]
                    break;
                case &quot;data-source&quot;:
                case &quot;technique&quot;:
                    this.addColumn(&quot;&quot;, &quot;workflow&quot;, &quot;icon&quot;);
                    this.addColumn(&quot;&quot;, &quot;state&quot;, &quot;icon&quot;);
                    this.addColumn(&quot;ID&quot;, &quot;attackID&quot;, &quot;plain&quot;, false);
                    this.addColumn(&quot;name&quot;, &quot;name&quot;, &quot;plain&quot;, sticky_allowed, [&quot;name&quot;]);
                    this.addColumn(&quot;platforms&quot;, &quot;platforms&quot;, &quot;list&quot;);
                    this.addColumn(&quot;domain&quot;, &quot;domains&quot;, &quot;list&quot;);
                    this.addVersionsAndDatesColumns();
                    this.tableDetail &#x3D; [{
                        &quot;field&quot;: &quot;description&quot;,
                        &quot;display&quot;: &quot;descriptive&quot;
                    }]
                    break;
                case &quot;data-component&quot;:
                    this.addColumn(&quot;name&quot;, &quot;name&quot;, &quot;plain&quot;, sticky_allowed, [&quot;name&quot;]);
                    this.addColumn(&quot;domain&quot;, &quot;domains&quot;, &quot;list&quot;);
                    this.addVersionsAndDatesColumns();
                    this.tableDetail &#x3D; [{
                        &quot;field&quot;: &quot;description&quot;,
                        &quot;display&quot;: &quot;descriptive&quot;
                    }]
                    break;
                case &quot;relationship&quot;:
                    this.addColumn(&quot;&quot;, &quot;state&quot;, &quot;icon&quot;);
                    if (this.config.relationshipType &amp;&amp; this.config.relationshipType !&#x3D;&#x3D; &quot;detects&quot;) {
                        this.addColumn(&quot;source&quot;, &quot;source_ID&quot;, &quot;plain&quot;);
                        this.addColumn(&quot;&quot;, &quot;source_name&quot;, &quot;plain&quot;, this.config.targetRef? sticky_allowed: false, [&quot;relationship-name&quot;]);// [&quot;name&quot;, &quot;relationship-left&quot;]);
                    } else this.addColumn(&quot;source&quot;, &quot;source_name&quot;, &quot;plain&quot;, this.config.targetRef? sticky_allowed: false, [&quot;relationship-name&quot;]);
                    this.addColumn(&quot;type&quot;, &quot;relationship_type&quot;, &quot;plain&quot;, false, [&quot;text-deemphasis&quot;, &quot;relationship-joiner&quot;]);
                    this.addColumn(&quot;target&quot;, &quot;target_ID&quot;, &quot;plain&quot;);
                    this.addColumn(&quot;&quot;, &quot;target_name&quot;, &quot;plain&quot;, this.config.sourceRef? sticky_allowed: false, [&quot;relationship-name&quot;]);// [&quot;name&quot;, &quot;relationship-right&quot;]);
                    if (!(this.config.relationshipType &amp;&amp; this.config.relationshipType &#x3D;&#x3D; &quot;subtechnique-of&quot;)) this.addColumn(&quot;description&quot;, &quot;description&quot;, &quot;descriptive&quot;, false);
                    break;
                case &quot;marking-definition&quot;:
                    this.addColumn(&quot;definition type&quot;, &quot;definition_type&quot;, &quot;plain&quot;);
                    this.addColumn(&quot;created&quot;, &quot;created&quot;, &quot;timestamp&quot;);
                    this.addColumn(&quot;definition&quot;, &quot;definition_string&quot;, &quot;descriptive&quot;);
                    this.tableDetail &#x3D; [{
                        &quot;field&quot;: &quot;definition_string&quot;,
                        &quot;display&quot;: &quot;descriptive&quot;
                    }]
                    break;
                default:
                    this.addColumn(&quot;type&quot;, &quot;attackType&quot;, &quot;plain&quot;);
                    this.addColumn(&quot;modified&quot;,&quot;modified&quot;, &quot;timestamp&quot;);
                    this.addColumn(&quot;created&quot;, &quot;created&quot;, &quot;timestamp&quot;);
            }
        }
        else {
            this.groupBy &#x3D; [&quot;type&quot;];
            this.addColumn(&quot;type&quot;, &quot;attackType&quot;, &quot;plain&quot;);
            this.addColumn(&quot;ID&quot;, &quot;attackID&quot;, &quot;plain&quot;, false);
            this.addColumn(&quot;name&quot;, &quot;name&quot;, &quot;plain&quot;, true, [&quot;name&quot;]);
            this.addColumn(&quot;modified&quot;,&quot;modified&quot;, &quot;timestamp&quot;);
            this.addColumn(&quot;created&quot;, &quot;created&quot;, &quot;timestamp&quot;);
        }
    }

    /**
     * Set up controls, including control columns and filters
     */
    private setUpControls(): void {
        //controls cols setup
        let controls_before &#x3D; [] // control columns which occur before the main columns
        let controls_after &#x3D; []; // control columns which occur after the main columns

        //selection setup
        if (&quot;select&quot; in this.config &amp;&amp; this.config.select !&#x3D; &quot;disabled&quot;) {
            if (&quot;selectionModel&quot; in this.config) {
                this.selection &#x3D; this.config.selectionModel;
            } else {
                this.selection &#x3D; new SelectionModel&lt;string&gt;(this.config.select &#x3D;&#x3D; &quot;many&quot;);
            }
            controls_before.unshift(&quot;select&quot;) // add select column to view
        }

        // open-link icon setup
        if (this.config.clickBehavior &amp;&amp; this.config.clickBehavior &#x3D;&#x3D; &quot;dialog&quot;) {
            controls_after.push(&quot;open-link&quot;)
        }

        // row action setup
        if (this.config.rowAction) {
            if (this.config.rowAction.position &#x3D;&#x3D; &quot;start&quot;) controls_before.push(&quot;start-action&quot;);
            else controls_after.push(&quot;end-action&quot;);
        }
        this.tableColumns_controls &#x3D; controls_before.concat(this.tableColumns, controls_after);

        // filter setup
        this.filterOptions.push({
            &quot;name&quot;: &quot;workflow status&quot;,
            &quot;disabled&quot;: &quot;status&quot; in this.config,
            &quot;values&quot;: this.statuses
        })
        this.filterOptions.push({
            &quot;name&quot;: &quot;state&quot;,
            &quot;disabled&quot;: &quot;status&quot; in this.config,
            &quot;values&quot;: this.states
        })
        let filterByDomain: boolean &#x3D; this.config.type ? [&#x27;data-source&#x27;, &#x27;mitigation&#x27;, &#x27;software&#x27;, &#x27;tactic&#x27;, &#x27;technique&#x27;].includes(this.config.type) : false;
        let filterByPlatform: boolean &#x3D; this.config.type ? [&#x27;data-source&#x27;, &#x27;software&#x27;, &#x27;technique&#x27;].includes(this.config.type) : false;
        if (filterByDomain) {
            this.filterOptions.push({
                &quot;name&quot;: &quot;domain&quot;,
                &quot;disabled&quot;: &quot;status&quot; in this.config,
                &quot;values&quot;: this.domains
            })
        }
        if (filterByPlatform) {
            // only build platform filters if config.type is defined and object has &#x27;x_mitre_platforms&#x27; field
            let platforms: FilterValue[] &#x3D; this.buildPlatformFilter(this.config.type);
            if (platforms.length) {
                this.filterOptions.push({
                    &quot;name&quot;: &quot;platform&quot;,
                    &quot;disabled&quot;: &quot;status&quot; in this.config,
                    &quot;values&quot;: platforms
                })
            }
        }

        // get data from config (if we are not connecting to back-end)
        if (&quot;stixObjects&quot; in this.config &amp;&amp; !(this.config.stixObjects instanceof Observable)) {
            this.totalObjectCount &#x3D; this.config.stixObjects.length;
            this.applyControls();
        }
    }

    /**
     * Add a column to the table
     * @param {string} label the label to display the field under; column name
     * @param {string} field the field to display
     * @param {string} display how to format the column data
     * @param {boolean} [sticky] is the column sticky? If true, the column will be static in the X scrolling of the view
     * @param {string[]} [classes] list of css classes to apply to the cell
     */
    private addColumn(label: string, field: string, display: &quot;version&quot; | &quot;list&quot; | &quot;plain&quot; | &quot;timestamp&quot; | &quot;descriptive&quot; | &quot;relationship_name&quot; | &quot;icon&quot;, sticky?: boolean, classes?: string[]) {
        this.tableColumns.push(field);
        this.tableColumns_settings.set(field, {label, display, sticky, classes});
    }

    /**
     * Add version, modified, and created columns to the table
     */
    private addVersionsAndDatesColumns() {
        this.addColumn(&quot;version&quot;, &quot;version&quot;, &quot;version&quot;);
        this.addColumn(&quot;modified&quot;,&quot;modified&quot;, &quot;timestamp&quot;);
        this.addColumn(&quot;created&quot;, &quot;created&quot;, &quot;timestamp&quot;);
    }

    /**
     * Handles row click events. Open the panel, or open a modal depending on object type
     * @param {StixObject} object of the row that was clicked
     */
    public rowClick(element: StixObject) {
        if (this.config.clickBehavior &amp;&amp; this.config.clickBehavior &#x3D;&#x3D; &quot;none&quot;) return;
        if (this.config.clickBehavior &amp;&amp; this.config.clickBehavior &#x3D;&#x3D; &quot;dialog&quot;) { //open modal
            let prompt &#x3D; this.dialog.open(StixDialogComponent, {
                data: {
                    object: element,
                    editable: this.config.allowEdits,
                    sidebarControl: this.config.allowEdits? &quot;events&quot; : &quot;disable&quot;
                },
                maxHeight: &quot;75vh&quot;
            })
            let subscription &#x3D; prompt.afterClosed().subscribe({
                next: result &#x3D;&gt; {
                    if (prompt.componentInstance.dirty) { //re-fetch values since an edit occurred
                        this.applyControls();
                        this.refresh.emit();
                    }
                },
                complete: () &#x3D;&gt; { subscription.unsubscribe(); }
            });
        }
        else if (this.config.clickBehavior &amp;&amp; this.config.clickBehavior &#x3D;&#x3D; &quot;linkToSourceRef&quot;) {
            let source_ref &#x3D; element[&#x27;source_ref&#x27;];
            // Get type to navigate from source_ref
            let type &#x3D; this.typeMap[source_ref.split(&#x27;--&#x27;)[0]];

            this.router.navigateByUrl(&#x27;/&#x27; + type + &#x27;/&#x27; + source_ref);
        }
        else if (this.config.clickBehavior &amp;&amp; this.config.clickBehavior &#x3D;&#x3D; &quot;linkToTargetRef&quot;) {
            let target_ref &#x3D; element[&#x27;target_ref&#x27;];
            // Get type to navigate from target_ref
            let type &#x3D; this.typeMap[target_ref.split(&#x27;--&#x27;)[0]];

            this.router.navigateByUrl(&#x27;/&#x27;+ type + &#x27;/&#x27; + target_ref);
        }
        else { //expand
            this.expandedElement &#x3D; this.expandedElement &#x3D;&#x3D;&#x3D; element ? null : element;
        }
    }

    // AUTHENTICATION FUNCTIONS
    
    public getAccessibleRoutes(attackType: string, routes: any[], ) {
        return routes.filter(route &#x3D;&gt; this.canAccess(attackType, route) &amp;&amp; this.canEdit(route));
    }

    private canAccess(attackType: string, route: any) {
        if (route.label &amp;&amp; route.label &#x3D;&#x3D; &#x27;edit&#x27; &amp;&amp; !this.authenticationService.canEdit(attackType)) {
            // user not authorized
            return false;
        }
        // user authorized
        return true;
    }

    private canEdit(route: any) {
        if (route.label &amp;&amp; route.label &#x3D;&#x3D; &#x27;edit&#x27; &amp;&amp; this.config.uneditableObject) {
            return false;
        }
        return true;
    }

    /**
     * Filter the given objects to those which include the query. Searches all string and string[] properties
     * @template T the input type
     * @param {string} query
     * @param {T[]} objects
     * @returns {T[]}
     * @memberof StixListComponent
     */
    private filterObjects&lt;T&gt;(query: string, objects: T[]): T[] {
        return objects.filter(obj &#x3D;&gt; {
            return Object.keys(obj).some(key &#x3D;&gt; {
                if (typeof obj[key] &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) return obj[key].toLowerCase().includes(query.toLowerCase())
                else if (Array.isArray(obj[key])) {
                    return obj[key].some(val &#x3D;&gt; {
                        if (typeof(val) &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
                            return val.toLowerCase().includes(query.toLowerCase());
                        }
                    })
                }
            })
        })
    }

    /**
     * Enable all filters for the given filter name
     * @param {string} name name of the filter group 
     */
    private enableAllFilters(name: string) {
        for (let group of this.filterOptions) {
            if (group.name &#x3D;&#x3D; name) {
                group.values.forEach(option &#x3D;&gt; option.disabled &#x3D; false);
            }
        }
    }

    /**
     * Build platform filter values for the given attack type
     */
    private buildPlatformFilter(attackType: string): FilterValue[] {
        let platforms: FilterValue[] &#x3D; [];
        let domainMap &#x3D; this.platformMap.get(attackType);
        if (domainMap) {
            // add platforms related to this attackType
            let values: Set&lt;string&gt; &#x3D; new Set();
            for (let platforms of domainMap.values()) {
                platforms.forEach(platform &#x3D;&gt; values.add(platform));
            }
            for (let value of values) {
                platforms.push({
                    &quot;value&quot;: &#x60;platform.${value}&#x60;,
                    &quot;label&quot;: value,
                    &quot;disabled&quot;: false
                });
            }
        }
        return platforms;
    }

    /**
     * Disable platform filters which are not in the list of selected domains.
     * All other platforms will be marked as enabled.
     * @param domains list of selected domain filters
     */
    private disablePlatformFilters(domains: string[]): void {
        if (!domains.length) return;
        // get set of valid platforms in the selected domains
        let validPlatforms: Set&lt;string&gt; &#x3D; new Set();
        let domainMap &#x3D; this.platformMap.get(this.config.type);
        if (!domainMap) return; // platforms not supported for this attack type
        for (let domain of domains) {
            let platforms &#x3D; domainMap.get(domain);
            if (platforms) {
                platforms.forEach(p &#x3D;&gt; validPlatforms.add(p));
            }
        }
        // set enabledness of platform filters
        for (let group of this.filterOptions) {
            if (group.name &#x3D;&#x3D; &#x27;platform&#x27;) {
                for (let option of group.values) {
                    let platform &#x3D; option.value.split(&quot;platform.&quot;)[1];
                    // disable platform filters not in the list of valid platforms
                    option.disabled &#x3D; !validPlatforms.has(platform);
                }
            }
        }
    }

    /**
     * Disable domain filters which do not support the list of selected platforms.
     * All other domains will be marked as enabled.
     * @param platforms list of selected platform filters
     */
    private disableDomainFilters(platforms: string[]): void {
        if (!platforms.length) return;
        // get set of domains the selected platforms are supported by
        let validDomains: Set&lt;string&gt; &#x3D; new Set();
        let domainMap &#x3D; this.platformMap.get(this.config.type);
        if (!domainMap) return; // domains not supported for this attack type
        for (let [domain, domainPlatforms] of domainMap.entries()) {
            // get intersection of selected platforms and the domain platforms
            let filtered &#x3D; domainPlatforms.filter(p &#x3D;&gt; platforms.includes(p));
            if (filtered.length) validDomains.add(domain);
        }
        // set enabledness of domain filters
        for (let group of this.filterOptions) {
            if (group.name &#x3D;&#x3D; &#x27;domain&#x27;) {
                for (let option of group.values) {
                    let domain &#x3D; option.value.split(&quot;domain.&quot;)[1];
                    // disable domain filters not in the list of valid domains
                    option.disabled &#x3D; !validDomains.has(domain);
                }
            }
        }
    }

    /**
     * Apply all controls and fetch objects from the back-end if configured
     */
    public applyControls() {
        if (&quot;stixObjects&quot; in this.config) {
            if (this.config.stixObjects instanceof Observable) {
                // pull objects out of observable
            } else {                
                // filter on STIX objects specified in the config
                let filtered &#x3D; this.config.stixObjects;
                // filter to objects matching searchString
                filtered &#x3D; this.filterObjects(this.searchQuery, filtered);
                // sort
                filtered &#x3D; filtered.sort((a, b) &#x3D;&gt; {
                    let x &#x3D; a as any;
                    let y &#x3D; b as any;
                    return x.hasOwnProperty(&quot;name&quot;) &amp;&amp; y.hasOwnProperty(&quot;name&quot;)? x.name.localeCompare(y.name) : x.stixID.localeCompare(y.stixID)
                })
                if (this.paginator) this.totalObjectCount &#x3D; filtered.length;
                
                // filter to only ones within the correct index range
                let startIndex &#x3D; this.paginator? this.paginator.pageIndex * this.paginator.pageSize : 0
                let endIndex &#x3D; this.paginator? startIndex + this.paginator.pageSize : 10;
                filtered &#x3D; filtered.slice(startIndex, endIndex);
                this.data$ &#x3D; of({
                    data: filtered,
                    pagination: {
                        total: this.config.stixObjects.length,
                        offset: startIndex,
                        limit: this.paginator? this.paginator.pageSize : 0
                    }
                });
            }
        } else {
            // fetch objects from backend
            let limit &#x3D; this.paginator? this.paginator.pageSize : 10;
            let offset &#x3D; this.paginator? this.paginator.pageIndex * limit : 0;
            let deprecated &#x3D; this.filter.includes(&quot;state.deprecated&quot;);
            let revoked &#x3D; this.filter.includes(&quot;state.revoked&quot;);

            // state filter
            let state &#x3D; this.filter.find((x) &#x3D;&gt; x.startsWith(&quot;status.&quot;));
            if (state) {
                state &#x3D; state.split(&quot;status.&quot;)[1];
                // disable other states
                for (let group of this.filterOptions) {
                    for (let option of group.values) {
                        if (option.value.startsWith(&quot;status.&quot;) &amp;&amp; !option.value.endsWith(state)) option.disabled &#x3D; true;
                    }
                }
            } else {
                // enable all states
                this.enableAllFilters(&#x27;workflow status&#x27;);
            }

            // platform filter
            let platforms: string[] &#x3D; this.filter.filter((x) &#x3D;&gt; x.startsWith(&quot;platform.&quot;));
            if (platforms.length) {
                platforms &#x3D; platforms.map(p &#x3D;&gt; p.split(&quot;platform.&quot;)[1]);
                // disable domains that do not support selected platforms
                this.disableDomainFilters(platforms);
            } else {
                // enable all domains
                this.enableAllFilters(&#x27;domain&#x27;);
            }

            // domain filter
            let domains: string[] &#x3D; this.filter.filter((x) &#x3D;&gt; x.startsWith(&quot;domain.&quot;));
            if (domains.length) {
                domains &#x3D; domains.map(d &#x3D;&gt; d.split(&quot;domain.&quot;)[1]);
                // disable platforms not in selected domains
                this.disablePlatformFilters(domains);
            } else {
                // enable all platforms
                this.enableAllFilters(&#x27;platform&#x27;);
            }
            
            let options &#x3D; {
                limit: limit, 
                offset: offset, 
                excludeIDs: this.config.excludeIDs, 
                search: this.searchQuery, 
                state: state, 
                includeRevoked: revoked, 
                includeDeprecated: deprecated,
                platforms: platforms,
                domains: domains
            }

            if (this.config.type &#x3D;&#x3D; &quot;software&quot;) this.data$ &#x3D; this.restAPIConnectorService.getAllSoftware(options);
            else if (this.config.type &#x3D;&#x3D; &quot;campaign&quot;) this.data$ &#x3D; this.restAPIConnectorService.getAllCampaigns(options);
            else if (this.config.type &#x3D;&#x3D; &quot;group&quot;) this.data$ &#x3D; this.restAPIConnectorService.getAllGroups(options);
            else if (this.config.type &#x3D;&#x3D; &quot;matrix&quot;) this.data$ &#x3D; this.restAPIConnectorService.getAllMatrices(options);
            else if (this.config.type &#x3D;&#x3D; &quot;mitigation&quot;) this.data$ &#x3D; this.restAPIConnectorService.getAllMitigations(options);
            else if (this.config.type &#x3D;&#x3D; &quot;tactic&quot;) this.data$ &#x3D; this.restAPIConnectorService.getAllTactics(options);
            else if (this.config.type &#x3D;&#x3D; &quot;technique&quot;) this.data$ &#x3D; this.restAPIConnectorService.getAllTechniques(options);
            else if (this.config.type.includes(&quot;collection&quot;)) this.data$ &#x3D; this.restAPIConnectorService.getAllCollections({search: this.searchQuery, versions: &quot;all&quot;});
            else if (this.config.type &#x3D;&#x3D; &quot;relationship&quot;) this.data$ &#x3D; this.restAPIConnectorService.getRelatedTo({sourceRef: this.config.sourceRef, targetRef: this.config.targetRef, sourceType: this.config.sourceType, targetType: this.config.targetType, relationshipType: this.config.relationshipType,  excludeSourceRefs: this.config.excludeSourceRefs, excludeTargetRefs: this.config.excludeTargetRefs, limit: limit, offset: offset, includeDeprecated: deprecated});
            else if (this.config.type &#x3D;&#x3D; &quot;data-source&quot;) this.data$ &#x3D; this.restAPIConnectorService.getAllDataSources(options);
            else if (this.config.type &#x3D;&#x3D; &quot;data-component&quot;) this.data$ &#x3D; this.restAPIConnectorService.getAllDataComponents(options);
            else if (this.config.type &#x3D;&#x3D; &quot;marking-definition&quot;) this.data$ &#x3D; this.restAPIConnectorService.getAllMarkingDefinitions(options);
            let subscription &#x3D; this.data$.subscribe({
                next: (data) &#x3D;&gt; { this.totalObjectCount &#x3D; data.pagination.total; },
                complete: () &#x3D;&gt; { subscription.unsubscribe() }
            })
        }
    }
    
    public showDeprecated(event) {
        if (event.checked) {
            this.filter.push(&quot;state.deprecated&quot;);
        } else {
            let i &#x3D; this.filter.indexOf(&quot;state.deprecated&quot;);
            if (i &gt;&#x3D; 0) {
                this.filter.splice(i, 1);
            }
        }
        this.applyControls();
    }

    public ngOnDestroy() {
        // prevent memory leaks
        if (this.searchSubscription) this.searchSubscription.unsubscribe();
        if (this.platformSubscription) this.platformSubscription.unsubscribe();
    }
}

//allowed types for StixListConfig
type type_attacktype &#x3D; &quot;collection&quot; | &quot;campaign&quot; | &quot;group&quot; | &quot;matrix&quot; | &quot;mitigation&quot; | &quot;software&quot; | &quot;tactic&quot; | &quot;technique&quot; | &quot;relationship&quot; | &quot;data-source&quot; | &quot;data-component&quot; | &quot;marking-definition&quot;;
type selection_types &#x3D; &quot;one&quot; | &quot;many&quot; | &quot;disabled&quot;
export interface StixListConfig {
    /* if specified, shows the given STIX objects in the table instead of loading from the back-end based on other configurations. */
    stixObjects?: Observable&lt;StixObject[]&gt; | StixObject[];

    /** STIX ID;s force the list to show relationships with the given source or target. Use with type&#x3D;&#x3D;&#x27;relationship&#x27; */
    sourceRef?: string;
    targetRef?: string;
    /** ATT&amp;CK Types force the list to show relationships only with those types, use with type &#x3D;&#x3D; &#x27;relationship&#x27; */
    sourceType?: type_attacktype;
    targetType?: type_attacktype;
    /** relationship type to get, use with type&#x3D;&#x3D;&#x27;relationship&#x27; */
    relationshipType?: string;

    /** force the list to show only this type */
    type?: type_attacktype | &quot;collection-created&quot; | &quot;collection-imported&quot;;
    /** force the list to show only objects matching this query */
    query?: any;

    /** can the user select in this list? allowed options:
     *     &quot;one&quot;: user can select a single element at a time
     *     &quot;many&quot;: user can select as many elements as they want
     *     &quot;disabled&quot;: do not allow selection (the same as omitting the config field)
     */
    select?: selection_types;
    /**
     * If provided, use this selection model of STIX IDs for tracking selection
     * Only relevant if &#x27;select&#x27; is also enabled. Also, will cause problems if multiple constructor pram is set according to &#x27;select&#x27;.
     */
    selectionModel?: SelectionModel&lt;string&gt;;
    /** show links to view/edit pages for relevant objects? */
    showLinks?: boolean;
    /** default false, if false hides the filter dropdown menu */
    showFilters?: boolean;
    /**
     * How should the table act when the row is clicked? default &quot;expand&quot;
     *     &quot;expand&quot;: expand the row to show additional detail
     *     &quot;dialog&quot;: open a dialog with the full object definition
     *     &quot;linkToSourceRef&quot;: clicking redirects to the source ref object
     *     &quot;linkToTargetRef&quot;: clicking redirects user to target ref object
     *     &quot;none&quot;: row is not clickable
     */
    clickBehavior?: &quot;expand&quot; | &quot;dialog&quot; | &quot;linkToSourceRef&quot; | &quot;linkToTargetRef&quot; | &quot;none&quot;;
    /**
     * Default false. If true, allows for edits of the objects in the table
     * when in dialog mode
     */
    allowEdits?: boolean;

    /**
     * Default false. If true, edits will be disabled for the object
     */
    uneditableObject?: boolean;
    
    excludeIDs?: string[]; //exclude objects with this ID from the list
    excludeSourceRefs?: string[]; //exclude relationships with this source_ref from the list
    excludeTargetRefs?: string[]; //exclude relationships with this target_ref from the list

    // if specified, adds an action button for each row
    rowAction?: {
        icon: string, // material icon for the button
        tooltip: string, // tooltip or descriptor of action
        position: &quot;start&quot; | &quot;end&quot; //start: occurs before first column; end: occurs after last column
    }
}

export interface FilterValue {
    value: string;
    label: string;
    disabled: boolean;
}
export interface FilterGroup {
    disabled?: boolean; //is the entire group disabled
    name: string;
    values: FilterValue[];
}</code></pre>
    </div>
</div>








                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'FilterValue.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>

       <script src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
