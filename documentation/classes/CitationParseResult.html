<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>attack-workbench-frontend documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">attack-workbench-frontend documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content class">
                   <div class="content-data">












<ol class="breadcrumb">
  <li>Classes</li>
  <li >CitationParseResult</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/app/classes/external-references.ts</code>
        </p>


            <p class="comment">
                <h3>Description</h3>
            </p>
            <p class="comment">
                <p>The results of parsing citations in a single field</p>

            </p>




            <section>
    <h3 id="index">Index</h3>
    <table class="table table-sm table-bordered index-table">
        <tbody>
                <tr>
                    <td class="col-md-4">
                        <h6><b>Properties</b></h6>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <ul class="index-list">
                            <li>
                                    <span class="modifier">Public</span>
                                <a href="#brokenCitations" >brokenCitations</a>
                            </li>
                            <li>
                                    <span class="modifier">Public</span>
                                <a href="#missingCitations" >missingCitations</a>
                            </li>
                            <li>
                                    <span class="modifier">Public</span>
                                <a href="#usedCitations" >usedCitations</a>
                            </li>
                        </ul>
                    </td>
                </tr>

                <tr>
                    <td class="col-md-4">
                        <h6><b>Methods</b></h6>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <ul class="index-list">
                            <li>
                                    <span class="modifier">Public</span>
                                <a href="#merge" >merge</a>
                            </li>
                        </ul>
                    </td>
                </tr>





        </tbody>
    </table>
</section>

            <section>
    <h3 id="constructor">Constructor</h3>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
<code>constructor(initData?: literal type)</code>
                    </td>
                </tr>
                        <tr>
                            <td class="col-md-4">
                                <div class="io-line">Defined in <a href="" data-line="428" class="link-to-prism">src/app/classes/external-references.ts:428</a></div>
                            </td>
                        </tr>

                <tr>
                    <td class="col-md-4">
                            <div>
                                    <b>Parameters :</b>
                                    <table class="params">
                                        <thead>
                                            <tr>
                                                <td>Name</td>
                                                    <td>Type</td>
                                                <td>Optional</td>
                                            </tr>
                                        </thead>
                                        <tbody>
                                                <tr>
                                                        <td>initData</td>
                                                  
                                                        <td>
                                                                    <code>literal type</code>
                                                        </td>
                                                  
                                                    <td>
                                                            Yes
                                                    </td>
                                                    
                                                </tr>
                                        </tbody>
                                    </table>
                            </div>
                    </td>
                </tr>
            </tbody>
        </table>
</section>

            <section>
    
    <h3 id="inputs">
        Properties
    </h3>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="brokenCitations"></a>
                    <span class="name">
                            <span class="modifier">Public</span>
                        <span ><b>brokenCitations</b></span>
                        <a href="#brokenCitations"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>    <code>Set&lt;string&gt;</code>

                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>new Set()</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                                <div class="io-line">Defined in <a href="" data-line="428" class="link-to-prism">src/app/classes/external-references.ts:428</a></div>
                        </td>
                    </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="missingCitations"></a>
                    <span class="name">
                            <span class="modifier">Public</span>
                        <span ><b>missingCitations</b></span>
                        <a href="#missingCitations"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>    <code>Set&lt;string&gt;</code>

                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>new Set()</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                                <div class="io-line">Defined in <a href="" data-line="426" class="link-to-prism">src/app/classes/external-references.ts:426</a></div>
                        </td>
                    </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="usedCitations"></a>
                    <span class="name">
                            <span class="modifier">Public</span>
                        <span ><b>usedCitations</b></span>
                        <a href="#usedCitations"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>    <code>Set&lt;string&gt;</code>

                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>new Set()</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                                <div class="io-line">Defined in <a href="" data-line="424" class="link-to-prism">src/app/classes/external-references.ts:424</a></div>
                        </td>
                    </tr>


        </tbody>
    </table>
</section>

            <section>
    
    <h3 id="methods">
        Methods
    </h3>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="merge"></a>
                    <span class="name">
                        <span class="modifier">Public</span>
                        <span ><b>merge</b></span>
                        <a href="#merge"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
            <tr>
                <td class="col-md-4">
                    <span class="modifier-icon icon ion-ios-reset"></span>
                    <code>merge(that: <a href="../classes/CitationParseResult.html" target="_self">CitationParseResult</a>)</code>
                </td>
            </tr>


            <tr>
                <td class="col-md-4">
                    <div class="io-line">Defined in <a href="" data-line="440"
                            class="link-to-prism">src/app/classes/external-references.ts:440</a></div>
                </td>
            </tr>


            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>Merge results from another CitationParseResult into this object</p>
</div>

                    <div class="io-description">
                        <b>Parameters :</b>
                        
                        <table class="params">
                            <thead>
                                <tr>
                                    <td>Name</td>
                                    <td>Type</td>
                                    <td>Optional</td>
                                    <td>Description</td>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>that</td>
                                    <td>
                                                <code><a href="../classes/CitationParseResult.html" target="_self" >CitationParseResult</a></code>
                                    </td>

                                    <td>
                                        No
                                    </td>


                                    <td>
                                        <p>results from other object</p>

                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <div>
                    </div>
                    <div class="io-description">
                        <b>Returns : </b>        <code><a href="https://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" >void</a></code>

                    </div>
                    <div class="io-description">
                        
                    </div>
                </td>
            </tr>
        </tbody>
    </table>
</section>





    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { forkJoin, Observable, of } from &quot;rxjs&quot;;
import { map } from &quot;rxjs/operators&quot;;
import { RestApiConnectorService } from &quot;../services/connectors/rest-api/rest-api-connector.service&quot;;
import { Serializable, ValidationData } from &quot;./serializable&quot;;
import { StixObject } from &quot;./stix/stix-object&quot;;
import { logger } from &quot;../util/logger&quot;;

export class ExternalReferences extends Serializable {
    private _externalReferences : Map&lt;string, ExternalReference&gt; &#x3D; new Map();
    private _externalReferencesIndex : Map&lt;string, number&gt; &#x3D; new Map();
    private usedReferences : string[] &#x3D; [];     // array to store used references
    private missingReferences : string[] &#x3D; [];  // array to store missing references
    private brokenCitations : string[] &#x3D; [];    // array to store broken citations

    /**
     * return external references list
     */
    public get externalReferences() { return this._externalReferences; }

    /**
     * Return list of external references in order
     */
    public list() : Array&lt;[number, ExternalReference]&gt; {
        let externalRefList : Array&lt;[number, ExternalReference]&gt; &#x3D; [];

        for (let [key, value] of this._externalReferencesIndex) {
            if (this.getReference(key)) externalRefList.push([value, this.getReference(key)]);
        }

        return externalRefList;
    }

    /**
     * Sort _externalReferences by alphabetical order
     * Restart map for displaying references
     */
    public sortReferences() : void {
        // Sort map by alphabetical order on descriptions
        this._externalReferences &#x3D; new Map([...this._externalReferences.entries()].sort((a,b) &#x3D;&gt; a[1].description.localeCompare(b[1].description)));
        
        // Restart _externalReferencesIndex map
        this._externalReferencesIndex &#x3D; new Map();
        // Start index at 1
        let index &#x3D; 1;
        // Index 1
        for (let [key, value] of this._externalReferences) {
            // Add to map if it has a description
            if(value.description){
                // Do not include if description has (Citation: *)
                if(!value.description.includes(&quot;(Citation:&quot;)) {
                    this._externalReferencesIndex.set(key, index);
                    index +&#x3D; 1;
                }
            }
        }
    }

    /**
     * Return index of reference to display
     * Returns null if not found
     * @param sourceName source name of reference
     */
    public getIndexOfReference(sourceName : string) : number {
        if(this._externalReferencesIndex.get(sourceName)) {
            return this._externalReferencesIndex.get(sourceName);
        }
        return null;
    }

    /**
     * Return if value exists in external references
     * @param sourceName source name of reference
     */
    public hasValue(sourceName: string) : boolean {
        if (this._externalReferences.get(sourceName)) {
            return true;
        }
        return false;
    }

    /**
     * Return description of reference
     * @param sourceName source name of reference
     */
    public getDescription(sourceName: string) : string {
        if (this._externalReferences.get(sourceName)) {
            let source &#x3D; this._externalReferences.get(sourceName)
            if (source[&quot;description&quot;]) {
                return source[&quot;description&quot;];
            }
        }
        return &quot;&quot;;
    }

    /**
     * Return ExternalReference object of given source name
     * return undefined if not found
     * @param sourceName source name of reference
     */
    public getReference(sourceName : string) : ExternalReference {
        return this._externalReferences.get(sourceName);
    }

    /**
     * Add ExternalReference object to external references list
     * @param sourceName source name of reference
     * @param externalReference external reference object
     */
    private addReference(sourceName : string, externalReference : ExternalReference) {
        if (sourceName &amp;&amp; externalReference) {
            this._externalReferences.set(sourceName, externalReference);
            // Sort references by description and update index map
            this.sortReferences()
        }
    }

    /**
     * Check if the reference is on the object, and add it if it is not.
     * Returns an observable that is true if the reference exists or has been added, and false if it couldn&#x27;t be added
     * @param {string} sourceName  source name string of references
     * @param {RestApiConnectorService} restApiConnector the service to get references
     * @returns {Observable&lt;boolean&gt;} true if references is found in object or global external reference list, false if not
     */
    private checkAndAddReference(sourceName : string, restApiConnector: RestApiConnectorService): Observable&lt;boolean&gt; {
        if (this.getReference(sourceName)) return of(true);
        return restApiConnector.getReference(sourceName).pipe(
            map((result) &#x3D;&gt; {
                let x &#x3D; result as any[];
                if (x.length &gt; 0) {
                    this.addReference(sourceName, x[0]);
                    return true;
                }
                return false;
            })
        );
    }

    /**
     * Parses object descriptive fields for citations and updates the
     * objects&#x27; external references list
     * @param object the object to parse citations within
     * @param restAPIConnector to connect to the REST API
     * @returns 
     */
    public parseObjectCitations(object: StixObject, restAPIConnector: RestApiConnectorService): Observable&lt;CitationParseResult&gt; {
        // get list of descriptive fields that support citations
        let refs_fields &#x3D; [&#x27;description&#x27;];
        if ([&#x27;software&#x27;, &#x27;group&#x27;, &#x27;campaign&#x27;].includes(object.attackType)) refs_fields.push(&#x27;aliases&#x27;);
        if (object.attackType &#x3D;&#x3D; &#x27;technique&#x27;) refs_fields.push(&#x27;detection&#x27;);
        if (object.attackType &#x3D;&#x3D; &#x27;campaign&#x27;) refs_fields.push(&#x27;first_seen_citation&#x27;, &#x27;last_seen_citation&#x27;);
        // parse citations for each descriptive field on the object
        let parse_apis &#x3D; [];
        for (let field of refs_fields) {
            if (field &#x3D;&#x3D; &#x27;aliases&#x27;) parse_apis.push(this.parseCitationsFromAliases(object[field], restAPIConnector));
            else parse_apis.push(this.parseCitations(object[field], restAPIConnector));
        }

        return forkJoin(parse_apis).pipe(
            map((api_results: CitationParseResult[]) &#x3D;&gt; {
                let citationResult &#x3D; new CitationParseResult();
                // merge all results into a single object
                for (let parse_result of api_results) {
                    citationResult.merge(parse_result);
                }
                // remove unused citations from external reference list
                this.removeUnusedReferences(Array.from(citationResult.usedCitations));
                return citationResult;
            })
        )
    }

    /**
     * Parses value for references
     * @param value the value to match citations within
     * @param restApiConnector to connect to the REST API
     */
    public parseCitations(value: string, restApiConnector: RestApiConnectorService): Observable&lt;CitationParseResult&gt; {
        let reReference &#x3D; /\(Citation: (.*?)\)/gmu;
        let citations &#x3D; value.match(reReference);
        let result &#x3D; new CitationParseResult({
            brokenCitations: this.validateBrokenCitations(value, [/\(Citation:([^ ].*?)\)/gmu, /\(citation:(.*?)\)/gmu])
        })

        if (citations) {
            // build lookup api map
            let api_map &#x3D; {};
            for (let i &#x3D; 0; i &lt; citations.length; i++) {
                // Split to get source name from citation
                let sourceName &#x3D; citations[i].split(&quot;(Citation: &quot;)[1].slice(0, -1);
                api_map[sourceName] &#x3D; this.checkAndAddReference(sourceName, restApiConnector);
            }
            // check/add each citation
            return forkJoin(api_map).pipe(
                map((api_results) &#x3D;&gt; {
                    let citation_results &#x3D; api_results as any;
                    for (let key of Object.keys(citation_results)) {
                        // was the result able to be found/added?
                        if (citation_results[key]) result.usedCitations.add(key)
                        else result.missingCitations.add(key)
                    }
                    return result;
                })
            )
        } else {
            return of(result);
        }
    }

    /**
     * validate given field for broken citation found by regular expression
     * @param field descriptive field that may contain citation
     * @param {regex[]} regExes regular expression
     */
    private validateBrokenCitations(field, regExes): Set&lt;string&gt; {
        let result &#x3D; new Set&lt;string&gt;();
        for (let regex of regExes) {
            let brokenReferences &#x3D; field.match(regex);
            if (brokenReferences) {
                for (let i &#x3D; 0; i &lt; brokenReferences.length; i++) {
                    result.add(brokenReferences[i]);
                }
            }
        }
        return result;
    }

    /**
     * Parse citations from aliases which stores descriptions in external references
     * Add missing references to object if found in global external reference list 
     * @param aliases list of alias names
     * @param restApiConnector to connect to the REST API
     */
    public parseCitationsFromAliases(aliases : string[], restApiConnector : RestApiConnectorService): Observable&lt;CitationParseResult&gt; {
        // Parse citations from the alias descriptions stored in external references
        let api_calls &#x3D; [];
        let result &#x3D; new CitationParseResult();
        for (let i &#x3D; 0; i &lt; aliases.length; i++) {
            if (this._externalReferences.get(aliases[i])) {
                result.usedCitations.add(aliases[i]);
                api_calls.push(this.parseCitations(this._externalReferences.get(aliases[i]).description, restApiConnector));
            }
        }
        if (api_calls.length &#x3D;&#x3D; 0) return of(result);
        else return forkJoin(api_calls).pipe( // get citation errors for each alias
            map((api_results) &#x3D;&gt; {
                let citation_results &#x3D; api_results as any;
                for (let citation_result of citation_results) { //merge into master list
                    result.merge(citation_result);
                }
                return result; //return master list
            })
        )
    }

    /**
     * Update external references map with given reference list
     * @param references list of references
     */
    public set externalReferences(references: any) {
        this._externalReferences &#x3D; new Map();
        this._externalReferencesIndex &#x3D; new Map();
        if (references){
            // Create externalReferences list
            for (let i &#x3D; 0; i &lt; references.length; i++){
                if (&quot;source_name&quot; in references[i] &amp;&amp; !(&quot;external_id&quot; in references[i])) {
                    let description &#x3D; &quot;&quot;
                    if(references[i].description) {
                        description &#x3D; references[i].description;
                    }
                    let url &#x3D; &quot;&quot;
                    if(references[i].url) {
                        url &#x3D; references[i].url;
                    }
    
                    let externalRef : ExternalReference &#x3D; {
                        url : url,
                        description : description
                    }
    
                    this._externalReferences.set(references[i][&#x27;source_name&#x27;], externalRef);
                }
            }

            // Sort references by description and update index map
            this.sortReferences()
        }
    }

    /**
     * Construct an external references object
     * optional @param references external references list from collection
     */
    constructor(references?) {
        super();
        if (references) this.deserialize(references);
    }

    /**
     *  Transform the current object into a raw object for sending to the back-end, stripping any unnecessary fields
     * @abstract
     * @returns {*} the raw object to send
     */
    public serialize(): ExternalReference[] {

        let rep: Array&lt;{}&gt; &#x3D; [];

        for (const [key, value] of this._externalReferences) {
            let temp &#x3D; {};

            temp[&quot;source_name&quot;] &#x3D; key; // do not trim source_name to prevent discrepancy between the Reference source_name and list of external references
            if (value[&quot;url&quot;]) temp[&quot;url&quot;] &#x3D; value[&quot;url&quot;].trim();
            if (value[&quot;description&quot;]) temp[&quot;description&quot;] &#x3D; value[&quot;description&quot;];
            
            rep.push(temp);
        }
        
        return rep;
    }
    /**
     * Parse the object from the record returned from the back-end
     * @abstract
     * @param {*} raw the raw object to parse
     */
    public deserialize(raw: any) {
        if (typeof(raw) &#x3D;&#x3D;&#x3D; &quot;object&quot;) this.externalReferences &#x3D; raw;
        else logger.error(&quot;TypeError: external_references field is not an object:&quot;, raw, &quot;(&quot;,typeof(raw),&quot;)&quot;)
    }

    /**
     * Remove references which do not have the source name
     *
     * @param {string[]} usedSourceNames the source names that are used on the object; all other source names will be removed
     * @memberof ExternalReferences
     */
    public removeUnusedReferences(usedSourceNames: string[]) {
        // Create temp external references map from used references
        // Resulting map will remove unused references
        let temp_externalReferences : Map&lt;string, ExternalReference&gt; &#x3D; new Map();
        for (let i &#x3D; 0; i &lt; usedSourceNames.length; i++) {
            let sourceName &#x3D; usedSourceNames[i];
            if (this._externalReferences.get(sourceName)) temp_externalReferences.set(sourceName, this._externalReferences.get(sourceName));
        }
        
        let pre_delete_keys &#x3D; Array.from(this._externalReferences.keys());
        // Update external references with used references
        this._externalReferences &#x3D; temp_externalReferences;
        let post_delete_keys &#x3D; Array.from(this._externalReferences.keys());
        logger.log(&quot;removed unused references&quot;, pre_delete_keys.filter((x) &#x3D;&gt; !post_delete_keys.includes(x)))
        // Sort references by description and update index map
        this.sortReferences()
    }

    /*
     * Validate the current object state and return information on the result of the validation
     * Also removes unused external references.
     * @returns {Observable&lt;ValidationData&gt;} the validation warnings and errors once validation is complete.
     */
    public validate(restAPIService: RestApiConnectorService, options: {fields: string[], object: StixObject}): Observable&lt;ValidationData&gt; {
        let result &#x3D; new ValidationData();
        let parse_apis &#x3D; [];
        for (let field of options.fields) {
            if (!Object.keys(options.object)) continue; //object does not implement the field
            if (field &#x3D;&#x3D; &quot;aliases&quot;) parse_apis.push(this.parseCitationsFromAliases(options.object[field], restAPIService))
            else parse_apis.push(this.parseCitations(options.object[field], restAPIService));
        }
        return forkJoin(parse_apis).pipe(
            map(api_results &#x3D;&gt; {
                let parse_results &#x3D; api_results as CitationParseResult[];
                let citationResult &#x3D; new CitationParseResult();
                for (let parse_result of parse_results) {
                    citationResult.merge(parse_result); //merge all results into a single object
                }
                // use merged object to remove unused citations
                this.removeUnusedReferences(Array.from(citationResult.usedCitations));

                // add to validation result

                // broken citations
                let brokenCitations &#x3D; Array.from(citationResult.brokenCitations);
                if (brokenCitations.length &#x3D;&#x3D; 1) result.errors.push({
                    result: &quot;error&quot;,
                    field: &quot;external_references&quot;, //TODO set this to the actual field to improve warnings
                    message: &#x60;Citation ${brokenCitations[0]} does not match format (Citation: source name)&#x60;
                }) 
                else if (brokenCitations.length &gt; 1) result.errors.push({
                    result: &quot;error&quot;,
                    field: &quot;external_references&quot;, //TODO set this to the actual field to improve warnings
                    message: &#x60;Citations ${brokenCitations.join(&quot;, &quot;)} do not match format (Citation: source name)&#x60;
                })

                //missing citations
                let missingCitations &#x3D; Array.from(citationResult.missingCitations);
                if (missingCitations.length &#x3D;&#x3D; 1) result.errors.push({
                    result: &quot;error&quot;,
                    field: &quot;external_references&quot;, //TODO set this to the actual field to improve warnings
                    message: &#x60;Cannot find reference: ${missingCitations[0]} &#x60;
                }) 
                else if (missingCitations.length &gt; 1) result.errors.push({
                    result: &quot;error&quot;,
                    field: &quot;external_references&quot;, //TODO set this to the actual field to improve warnings
                    message: &#x60;Cannot find references: ${missingCitations.join(&quot;, &quot;)}&#x60;
                })
                //return the result
                return result;
            })
        )
    }
}

export interface ExternalReference {
    /** source name of the reference */
    source_name?: string;
    /** url; url of reference */
    url?: string;
    /** description; description of reference */
    description?: string;
}

/**
 * The results of parsing citations in a single field
 */
export class CitationParseResult {
    //list of reference source names which have been used in this field
    public usedCitations: Set&lt;string&gt; &#x3D; new Set();
    //citations that could not be found
    public missingCitations: Set&lt;string&gt; &#x3D; new Set();
    // list of broken references detected in the field
    public brokenCitations: Set&lt;string&gt; &#x3D; new Set(); 

    constructor(initData?: {usedCitations?: Set&lt;string&gt;, missingCitations?: Set&lt;string&gt;, brokenCitations: Set&lt;string&gt;}) {
        if (initData &amp;&amp; initData.usedCitations) this.usedCitations &#x3D; initData.usedCitations;
        if (initData &amp;&amp; initData.missingCitations) this.missingCitations &#x3D; initData.missingCitations;
        if (initData &amp;&amp; initData.brokenCitations) this.brokenCitations &#x3D; initData.brokenCitations;
    }

    /**
     * Merge results from another CitationParseResult into this object
     * @param {CitationParseResult} that results from other object
     */
    public merge(that: CitationParseResult) {
        this.usedCitations &#x3D; new Set([...this.usedCitations, ...that.usedCitations]);
        this.missingCitations &#x3D; new Set([...this.missingCitations, ...that.missingCitations]);
        this.brokenCitations &#x3D; new Set([...this.brokenCitations, ...that.brokenCitations]);
    }
}</code></pre>
    </div>
</div>









                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'class';
            var COMPODOC_CURRENT_PAGE_URL = 'CitationParseResult.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>

       <script src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
