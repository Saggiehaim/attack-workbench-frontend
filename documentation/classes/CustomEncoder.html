<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>attack-workbench-frontend documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">attack-workbench-frontend documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content class">
                   <div class="content-data">












<ol class="breadcrumb">
  <li>Classes</li>
  <li >CustomEncoder</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/app/services/connectors/rest-api/rest-api-connector.service.ts</code>
        </p>




            <p class="comment">
                <h3>Implements</h3>
            </p>
            <p class="comment">
                            <code><a href="https://angular.io/api/common/http/HttpParameterCodec" target="_blank" >HttpParameterCodec</a></code>
            </p>


            <section>
    <h3 id="index">Index</h3>
    <table class="table table-sm table-bordered index-table">
        <tbody>

                <tr>
                    <td class="col-md-4">
                        <h6><b>Methods</b></h6>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <ul class="index-list">
                            <li>
                                <a href="#decodeKey" >decodeKey</a>
                            </li>
                            <li>
                                <a href="#decodeValue" >decodeValue</a>
                            </li>
                            <li>
                                <a href="#encodeKey" >encodeKey</a>
                            </li>
                            <li>
                                <a href="#encodeValue" >encodeValue</a>
                            </li>
                        </ul>
                    </td>
                </tr>





        </tbody>
    </table>
</section>



            <section>
    
    <h3 id="methods">
        Methods
    </h3>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="decodeKey"></a>
                    <span class="name">
                        <span ><b>decodeKey</b></span>
                        <a href="#decodeKey"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
            <tr>
                <td class="col-md-4">
<code>decodeKey(key: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank">string</a>)</code>
                </td>
            </tr>


            <tr>
                <td class="col-md-4">
                    <div class="io-line">Defined in <a href="" data-line="1629"
                            class="link-to-prism">src/app/services/connectors/rest-api/rest-api-connector.service.ts:1629</a></div>
                </td>
            </tr>


            <tr>
                <td class="col-md-4">

                    <div class="io-description">
                        <b>Parameters :</b>
                        
                        <table class="params">
                            <thead>
                                <tr>
                                    <td>Name</td>
                                    <td>Type</td>
                                    <td>Optional</td>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>key</td>
                                    <td>
                                                <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
                                    </td>

                                    <td>
                                        No
                                    </td>


                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <div>
                    </div>
                    <div class="io-description">
                        <b>Returns : </b>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                    </div>
                    <div class="io-description">
                        
                    </div>
                </td>
            </tr>
        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="decodeValue"></a>
                    <span class="name">
                        <span ><b>decodeValue</b></span>
                        <a href="#decodeValue"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
            <tr>
                <td class="col-md-4">
<code>decodeValue(value: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank">string</a>)</code>
                </td>
            </tr>


            <tr>
                <td class="col-md-4">
                    <div class="io-line">Defined in <a href="" data-line="1632"
                            class="link-to-prism">src/app/services/connectors/rest-api/rest-api-connector.service.ts:1632</a></div>
                </td>
            </tr>


            <tr>
                <td class="col-md-4">

                    <div class="io-description">
                        <b>Parameters :</b>
                        
                        <table class="params">
                            <thead>
                                <tr>
                                    <td>Name</td>
                                    <td>Type</td>
                                    <td>Optional</td>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>value</td>
                                    <td>
                                                <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
                                    </td>

                                    <td>
                                        No
                                    </td>


                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <div>
                    </div>
                    <div class="io-description">
                        <b>Returns : </b>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                    </div>
                    <div class="io-description">
                        
                    </div>
                </td>
            </tr>
        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="encodeKey"></a>
                    <span class="name">
                        <span ><b>encodeKey</b></span>
                        <a href="#encodeKey"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
            <tr>
                <td class="col-md-4">
<code>encodeKey(key: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank">string</a>)</code>
                </td>
            </tr>


            <tr>
                <td class="col-md-4">
                    <div class="io-line">Defined in <a href="" data-line="1623"
                            class="link-to-prism">src/app/services/connectors/rest-api/rest-api-connector.service.ts:1623</a></div>
                </td>
            </tr>


            <tr>
                <td class="col-md-4">

                    <div class="io-description">
                        <b>Parameters :</b>
                        
                        <table class="params">
                            <thead>
                                <tr>
                                    <td>Name</td>
                                    <td>Type</td>
                                    <td>Optional</td>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>key</td>
                                    <td>
                                                <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
                                    </td>

                                    <td>
                                        No
                                    </td>


                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <div>
                    </div>
                    <div class="io-description">
                        <b>Returns : </b>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                    </div>
                    <div class="io-description">
                        
                    </div>
                </td>
            </tr>
        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="encodeValue"></a>
                    <span class="name">
                        <span ><b>encodeValue</b></span>
                        <a href="#encodeValue"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
            <tr>
                <td class="col-md-4">
<code>encodeValue(value: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank">string</a>)</code>
                </td>
            </tr>


            <tr>
                <td class="col-md-4">
                    <div class="io-line">Defined in <a href="" data-line="1626"
                            class="link-to-prism">src/app/services/connectors/rest-api/rest-api-connector.service.ts:1626</a></div>
                </td>
            </tr>


            <tr>
                <td class="col-md-4">

                    <div class="io-description">
                        <b>Parameters :</b>
                        
                        <table class="params">
                            <thead>
                                <tr>
                                    <td>Name</td>
                                    <td>Type</td>
                                    <td>Optional</td>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>value</td>
                                    <td>
                                                <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
                                    </td>

                                    <td>
                                        No
                                    </td>


                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <div>
                    </div>
                    <div class="io-description">
                        <b>Returns : </b>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                    </div>
                    <div class="io-description">
                        
                    </div>
                </td>
            </tr>
        </tbody>
    </table>
</section>





    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { HttpClient, HttpHeaders, HttpParameterCodec, HttpParams } from &#x27;@angular/common/http&#x27;;
import { Injectable } from &#x27;@angular/core&#x27;;
import { MatSnackBar } from &#x27;@angular/material/snack-bar&#x27;;
import { forkJoin, Observable, of } from &#x27;rxjs&#x27;;
import { tap, catchError, map, share, switchMap, mergeMap } from &#x27;rxjs/operators&#x27;;
import { CollectionIndex } from &#x27;src/app/classes/collection-index&#x27;;
import { ExternalReference } from &#x27;src/app/classes/external-references&#x27;;
import { Collection } from &#x27;src/app/classes/stix/collection&#x27;;
import { Group } from &#x27;src/app/classes/stix/group&#x27;;
import { Identity } from &#x27;src/app/classes/stix/identity&#x27;;
import { MarkingDefinition } from &#x27;src/app/classes/stix/marking-definition&#x27;;
import { Matrix } from &#x27;src/app/classes/stix/matrix&#x27;;
import { Mitigation } from &#x27;src/app/classes/stix/mitigation&#x27;;
import { Note } from &#x27;src/app/classes/stix/note&#x27;;
import { Relationship } from &#x27;src/app/classes/stix/relationship&#x27;;
import { Software } from &#x27;src/app/classes/stix/software&#x27;;
import { StixObject } from &#x27;src/app/classes/stix/stix-object&#x27;;
import { Tactic } from &#x27;src/app/classes/stix/tactic&#x27;;
import { Technique } from &#x27;src/app/classes/stix/technique&#x27;;
import { environment } from &quot;../../../../environments/environment&quot;;
import { ApiConnector } from &#x27;../api-connector&#x27;;
import { logger } from &quot;../../../util/logger&quot;;
import { DataSource } from &#x27;src/app/classes/stix/data-source&#x27;;
import { DataComponent } from &#x27;src/app/classes/stix/data-component&#x27;;
import { UserAccount } from &#x27;src/app/classes/authn/user-account&#x27;;
import { Campaign } from &#x27;src/app/classes/stix/campaign&#x27;;

//attack types
type AttackType &#x3D; &quot;campaign&quot; | &quot;collection&quot; | &quot;group&quot; | &quot;matrix&quot; | &quot;mitigation&quot; | &quot;software&quot; | &quot;tactic&quot; | &quot;technique&quot; | &quot;relationship&quot; | &quot;note&quot; | &quot;identity&quot; | &quot;marking-definition&quot; | &quot;data-source&quot; | &quot;data-component&quot;;
// pluralize AttackType
const attackTypeToPlural &#x3D; {
    &quot;technique&quot;: &quot;techniques&quot;,
    &quot;tactic&quot;: &quot;tactics&quot;,
    &quot;group&quot;: &quot;groups&quot;,
    &quot;campaign&quot;: &quot;campaigns&quot;,
    &quot;software&quot;: &quot;software&quot;,
    &quot;mitigation&quot;: &quot;mitigations&quot;,
    &quot;matrix&quot;: &quot;matrices&quot;,
    &quot;collection&quot;: &quot;collections&quot;,
    &quot;relationship&quot;: &quot;relationships&quot;,
    &quot;note&quot;: &quot;notes&quot;,
    &quot;identity&quot;: &quot;identities&quot;,
    &quot;marking-definition&quot;: &quot;marking-definitions&quot;,
    &quot;data-source&quot;: &quot;data-sources&quot;,
    &quot;data-component&quot;: &quot;data-components&quot;
}
// transform AttackType to the relevant class
const attackTypeToClass &#x3D; {
    &quot;technique&quot;: Technique,
    &quot;tactic&quot;: Tactic,
    &quot;group&quot;: Group,
    &quot;campaign&quot;: Campaign,
    &quot;software&quot;: Software,
    &quot;mitigation&quot;: Mitigation,
    &quot;matrix&quot;: Matrix,
    &quot;collection&quot;: Collection,
    &quot;relationship&quot;: Relationship,
    &quot;note&quot;: Note,
    &quot;identity&quot;: Identity,
    &quot;marking-definition&quot;: MarkingDefinition,
    &quot;data-source&quot;: DataSource,
    &quot;data-component&quot;: DataComponent
}

// transform AttackType to the relevant class
const stixTypeToClass &#x3D; {
    &quot;attack-pattern&quot;: Technique,
    &quot;x-mitre-tactic&quot;: Tactic,
    &quot;intrusion-set&quot;: Group,
    &quot;campaign&quot;: Campaign,
    &quot;tool&quot;: Software,
    &quot;malware&quot;: Software,
    &quot;course-of-action&quot;: Mitigation,
    &quot;x-mitre-matrix&quot;: Matrix,
    &quot;x-mitre-collection&quot;: Collection,
    &quot;relationship&quot;: Relationship,
    &quot;identity&quot;: Identity,
    &quot;marking-definition&quot;: MarkingDefinition,
    &quot;x-mitre-data-source&quot;: DataSource,
    &quot;x-mitre-data-component&quot;: DataComponent,
    &quot;note&quot;: Note
}

export interface Paginated&lt;T&gt; {
    data: T[],
    pagination: {
        total: number,
        limit: number,
        offset: number
    }
}

export interface Namespace {
    prefix: string,
    range_start: string
}

@Injectable({
    providedIn: &#x27;root&#x27;
})
export class RestApiConnectorService extends ApiConnector {
    private get baseUrl(): string { return environment.integrations.rest_api.url; }

    constructor(private http: HttpClient, private snackbar: MatSnackBar) { super(snackbar); }
    /**
     * Get the name of a given STIX object
     */
    private getObjectName(object: StixObject): string {
        if (object.type &#x3D;&#x3D; &quot;relationship&quot;) {
            if (object[&quot;source_name&quot;] &#x3D;&#x3D; &#x27;[unknown object]&#x27; || object[&quot;target_name&quot;] &#x3D;&#x3D; &#x27;[unknown object]&#x27;) {
                return &#x60;${object[&quot;relationship_type&quot;].charAt(0).toUpperCase()}${object[&quot;relationship_type&quot;].slice(1)} relationship&#x60;;
            }
            return &#x60;${object[&quot;source_name&quot;]} ${object[&quot;relationship_type&quot;]} ${object[&quot;target_name&quot;]}&#x60;;
        } else if (object.type &#x3D;&#x3D; &quot;note&quot;) {
            return object[&quot;title&quot;];
        } else if (&quot;name&quot; in object) {
            return object[&quot;name&quot;];
        } else if (object[&quot;attackID&quot;]) {
            return object[&quot;attackID&quot;];
        } else {
            logger.warn(&quot;could not determine object name&quot;, object)
            return &quot;unknown object&quot;;
        }
    }

    //   ___ _____ _____  __       _   ___ ___ ___
    //  / __|_   _|_ _\ \/ /      /_\ | _ \_ _/ __|
    //  \__ \ | |  | | &gt;  &lt;      / _ \|  _/| |\__ \
    //  |___/ |_| |___/_/\_\    /_/ \_\_| |___|___/
    //

    /**
     * Factory to create a new STIX get-all function
     * @template T the type to get
     * @param {AttackType} attackType the type to get
     * @returns getter function
     */
    private getStixObjectsFactory&lt;T extends StixObject&gt;(attackType: AttackType) {
        let attackClass &#x3D; attackTypeToClass[attackType];
        let plural &#x3D; attackTypeToPlural[attackType]
        return function&lt;P extends T&gt;(options?: { limit?: number, 
                                                 offset?: number, 
                                                 state?: string, 
                                                 includeRevoked?: boolean, 
                                                 includeDeprecated?: boolean, 
                                                 versions?: &quot;all&quot; | &quot;latest&quot;, 
                                                 excludeIDs?: string[], 
                                                 search?: string,
                                                 platforms?: string[],
                                                 domains?: string[]
                                                 }): Observable&lt;Paginated&lt;StixObject&gt;&gt; {
            // parse params into query string
            let query &#x3D; new HttpParams({encoder: new CustomEncoder()});
            if (options) {
                // pagination
                if (options.limit) query &#x3D; query.set(&quot;limit&quot;, options.limit.toString());
                if (options.offset) query &#x3D; query.set(&quot;offset&quot;, options.offset.toString());
                if (options.limit || options.offset) query &#x3D; query.set(&quot;includePagination&quot;, &quot;true&quot;);
                // state/workflow
                if (options.state) query &#x3D; query.set(&quot;state&quot;, options.state);
                if (options.includeRevoked) query &#x3D; query.set(&quot;includeRevoked&quot;, options.includeRevoked ? &quot;true&quot; : &quot;false&quot;);
                if (options.includeDeprecated) query &#x3D; query.set(&quot;includeDeprecated&quot;, options.includeDeprecated ? &quot;true&quot; : &quot;false&quot;);
                // versions selector
                if (options.versions) query &#x3D; query.set(&quot;versions&quot;, options.versions);
                // searching
                if (options.search) query &#x3D; query.set(&quot;search&quot;, options.search);
                // platforms/domains
                if (options.platforms) options.platforms.forEach(platform &#x3D;&gt; query &#x3D; query.append(&#x27;platform&#x27;, platform));
                if (options.domains) options.domains.forEach(domain &#x3D;&gt; query &#x3D; query.append(&#x27;domain&#x27;, domain));
            }
            // perform the request
            let url &#x3D; &#x60;${this.baseUrl}/${plural}&#x60;;
            return this.http.get(url, {headers: this.headers, params: query}).pipe(
                tap(results &#x3D;&gt; logger.log(&#x60;retrieved ${plural}&#x60;, results)), // on success, trigger the success notification
                map(results &#x3D;&gt; {
                    if (!options || !options.excludeIDs) return results; // only filter if param is present
                    let response &#x3D; results as any;
                    if (options &amp;&amp; (options.limit || options.offset)) { // returned a paginated
                        response.data &#x3D; response.data.filter((d) &#x3D;&gt; !options.excludeIDs.includes(d.stix.id)); //remove any matches to excludeIDs
                        return response;
                    } else { //returned a stixObject[]
                        response &#x3D; response.filter((d) &#x3D;&gt; !options.excludeIDs.includes(d.stix.id)); //remove any matches to excludeIDs
                        return response;
                    }
                }),
                map(results &#x3D;&gt; {
                    let response &#x3D; results as any;
                    if (options &amp;&amp; (options.limit || options.offset)) { // returned a paginated
                        let data &#x3D; response.data as Array&lt;any&gt;;
                        data &#x3D; data.map(y &#x3D;&gt; {
                            if (y.stix.type &#x3D;&#x3D; &quot;malware&quot; || y.stix.type &#x3D;&#x3D; &quot;tool&quot;) return new Software(y.stix.type, y);
                            else return new attackClass(y);
                        });
                        response.data &#x3D; data;
                        return response;
                    } else { //returned a stixObject[]
                        return {
                            pagination: {
                                total: response.length,
                                limit: -1,
                                offset: -1
                            },
                            data: response.map(y &#x3D;&gt; {
                                if (y.stix.type &#x3D;&#x3D; &quot;malware&quot; || y.stix.type &#x3D;&#x3D; &quot;tool&quot;) return new Software(y.stix.type, y);
                                else return new attackClass(y);
                            })
                        }
                    }
                }),
                catchError(this.handleError_continue([])), // on error, trigger the error notification and continue operation without crashing (returns empty item)
                share() // multicast so that multiple subscribers don&#x27;t trigger the call twice. THIS MUST BE THE LAST LINE OF THE PIPE
            )
        }
    }

    /**
     * Get all techniques
     * @param {number} [limit] the number of techniques to retrieve
     * @param {number} [offset] the number of techniques to skip
     * @param {string} [state] if specified, only get objects with this state
     * @param {boolean} [revoked] if true, get revoked objects
     * @param {boolean} [deprecated] if true, get deprecated objects
     * @param {string[]} [excludeIDs] if specified, excludes these STIX IDs from the result
     * @returns {Observable&lt;Technique[]&gt;} observable of retrieved objects
     */
    public get getAllTechniques() { return this.getStixObjectsFactory&lt;Technique&gt;(&quot;technique&quot;); }
    /**
     * Get all tactics
     * @param {number} [limit] the number of tactics to retrieve
     * @param {number} [offset] the number of tactics to skip
     * @param {string} [state] if specified, only get objects with this state
     * @param {boolean} [revoked] if true, get revoked objects
     * @param {boolean} [deprecated] if true, get deprecated objects
     * @param {string[]} [excludeIDs] if specified, excludes these STIX IDs from the result
     * @returns {Observable&lt;Tactic[]&gt;} observable of retrieved objects
     */
    public get getAllTactics() { return this.getStixObjectsFactory&lt;Tactic&gt;(&quot;tactic&quot;); }
    /**
     * Get all groups
     * @param {number} [limit] the number of groups to retrieve
     * @param {number} [offset] the number of groups to skip
     * @param {string} [state] if specified, only get objects with this state
     * @param {boolean} [revoked] if true, get revoked objects
     * @param {boolean} [deprecated] if true, get deprecated objects
     * @param {string[]} [excludeIDs] if specified, excludes these STIX IDs from the result
     * @returns {Observable&lt;Group[]&gt;} observable of retrieved objects
     */
    public get getAllGroups() { return this.getStixObjectsFactory&lt;Group&gt;(&quot;group&quot;); }
    /**
     * Get all campaigns
     * @param {number} [limit] the number of campaigns to retrieve
     * @param {number} [offset] the number of campaigns to skip
     * @param {string} [state] if specified, only get objects with this state
     * @param {boolean} [revoked] if true, get revoked objects
     * @param {boolean} [deprecated] if true, get deprecated objects
     * @param {string[]} [excludeIDs] if specified, excludes these STIX IDs from the result
     * @returns {Observable&lt;Campaign[]&gt;} observable of retrieved objects
     */
    public get getAllCampaigns() { return this.getStixObjectsFactory&lt;Campaign&gt;(&quot;campaign&quot;); }
    /**
     * Get all software
     * @param {number} [limit] the number of software to retrieve
     * @param {number} [offset] the number of software to skip
     * @param {string} [state] if specified, only get objects with this state
     * @param {boolean} [revoked] if true, get revoked objects
     * @param {boolean} [deprecated] if true, get deprecated objects
     * @returns {Observable&lt;Software[]&gt;} observable of retrieved objects
     */
    public get getAllSoftware() { return this.getStixObjectsFactory&lt;Software&gt;(&quot;software&quot;); }
    /**
     * Get all mitigations
     * @param {number} [limit] the number of mitigations to retrieve
     * @param {number} [offset] the number of mitigations to skip
     * @param {string} [state] if specified, only get objects with this state
     * @param {boolean} [revoked] if true, get revoked objects
     * @param {boolean} [deprecated] if true, get deprecated objects
     * @param {string[]} [excludeIDs] if specified, excludes these STIX IDs from the result
     * @returns {Observable&lt;Mitigation[]&gt;} observable of retrieved objects
     */
    public get getAllMitigations() { return this.getStixObjectsFactory&lt;Mitigation&gt;(&quot;mitigation&quot;); }
    /**
     * Get all data sources
     * @param {number} [limit] the number of data sources to retrieve
     * @param {number} [offset] the number of data sources to skip
     * @param {string} [state] if specified, only get objects with this state
     * @param {boolean} [revoked] if true, get revoked objects
     * @param {boolean} [deprecated] if true, get deprecated objects
     * @param {string[]} [excludeIDs] if specified, excludes these STIX IDs from the result
     * @returns {Observable&lt;DataSource[]&gt;} observable of retrieved objects
     */
    public get getAllDataSources() { return this.getStixObjectsFactory&lt;DataSource&gt;(&quot;data-source&quot;); }
    /**
     * Get all data components
     * @param {number} [limit] the number of data components to retrieve
     * @param {number} [offset] the number of data components to skip
     * @param {string} [state] if specified, only get objects with this state
     * @param {boolean} [revoked] if true, get revoked objects
     * @param {boolean} [deprecated] if true, get deprecated objects
     * @param {string[]} [excludeIDs] if specified, excludes these STIX IDs from the result
     * @returns {Observable&lt;DataComponent[]&gt;} observable of retrieved objects
     */
    public get getAllDataComponents() { return this.getStixObjectsFactory&lt;DataComponent&gt;(&quot;data-component&quot;); }
    /**
     * Get all matrices
     * @param {number} [limit] the number of matrices to retrieve
     * @param {number} [offset] the number of matrices to skip
     * @param {string} [state] if specified, only get objects with this state
     * @param {boolean} [revoked] if true, get revoked objects
     * @param {boolean} [deprecated] if true, get deprecated objects
     * @param {string[]} [excludeIDs] if specified, excludes these STIX IDs from the result
     * @returns {Observable&lt;Matrix[]&gt;} observable of retrieved objects
     */
    public get getAllMatrices() { return this.getStixObjectsFactory&lt;Matrix&gt;(&quot;matrix&quot;); }
    /**
     * Get all collections
     * @param {number} [limit] the number of collections to retrieve
     * @param {number} [offset] the number of collections to skip
     * @param {string} [state] if specified, only get objects with this state
     * @param {boolean} [revoked] if true, get revoked objects
     * @param {versions} [&quot;all&quot; | &quot;latest&quot;] if &quot;all&quot;, get all versions of the collections. if &quot;latest&quot;, only get the latest version of each collection.
     * @param {boolean} [deprecated] if true, get deprecated objects
     * @param {string[]} [excludeIDs] if specified, excludes these STIX IDs from the result
     * @returns {Observable&lt;Collection[]&gt;} observable of retrieved objects
     */
    public get getAllCollections() { return this.getStixObjectsFactory&lt;Collection&gt;(&quot;collection&quot;); }
    /**
     * Get all marking definitions
     * @param {number} [limit] the number of marking definitions to retrieve
     * @param {number} [offset] the number of marking definitions to skip
     * @param {string} [state] if specified, only get objects with this state
     * @param {boolean} [revoked] if true, get revoked objects
     * @param {versions} [&quot;all&quot; | &quot;latest&quot;] if &quot;all&quot;, get all versions of the marking definitions. if &quot;latest&quot;, only get the latest version of each collection.
     * @param {boolean} [deprecated] if true, get deprecated objects
     * @param {string[]} [excludeIDs] if specified, excludes these STIX IDs from the result
     * @returns {Observable&lt;MarkingDefinition[]&gt;} observable of retrieved objects
     */
    public get getAllMarkingDefinitions() { return this.getStixObjectsFactory&lt;Collection&gt;(&quot;marking-definition&quot;); }
    /**
     * Get all notes
     * @param {number} [limit] the number of notes to retrieve
     * @param {number} [offset] the number of notes to skip
     * @param {string} [state] if specified, only get objects with this state
     * @param {boolean} [revoked] if true, get revoked objects
     * @param {boolean} [deprecated] if true, get deprecated objects
     * @param {string[]} [excludeIDs] if specified, excludes these STIX IDs from the result
     * @returns {Observable&lt;Note[]&gt;} observable of retrieved objects
     */
    public get getAllNotes() { return this.getStixObjectsFactory&lt;Note&gt;(&quot;note&quot;); }
    /**
     * Get all identities
     * @param {number} [limit] the number of identities to retrieve
     * @param {number} [offset] the number of identities to skip
     * @param {string} [state] if specified, only get objects with this state
     * @param {boolean} [revoked] if true, get revoked objects
     * @param {boolean} [deprecated] if true, get deprecated objects
     * @param {string[]} [excludeIDs] if specified, excludes these STIX IDs from the result
     * @returns {Observable&lt;Identity[]&gt;} observable of retrieved objects
     */
     public get getAllIdentities() { return this.getStixObjectsFactory&lt;Identity&gt;(&quot;identity&quot;); }
    /**
     * Get all relationships
     * @param {number} [limit] the number of relationships to retrieve
     * @param {number} [offset] the number of relationships to skip
     * @param {string} [state] if specified, only get objects with this state
     * @param {boolean} [revoked] if true, get revoked objects
     * @param {versions} [&quot;all&quot; | &quot;latest&quot;] if &quot;all&quot;, get all versions of the relationships. if &quot;latest&quot;, only get the latest version of each collection.
     * @param {boolean} [deprecated] if true, get deprecated objects
     * @param {string[]} [excludeIDs] if specified, excludes these STIX IDs from the result
     * @returns {Observable&lt;Relationships[]&gt;} observable of retrieved objects
     */
    public get getAllRelationships() { return this.getStixObjectsFactory&lt;Relationship&gt;(&quot;relationship&quot;); }

    /**
     * Get all objects; objects will not be deserialized to STIX objects unless the parameter is used
     * @param {string[]} [attackIDs] filter to only include objects within the list of given ATT&amp;CK IDs
     * @param {number} [limit] the number of collections to retrieve
     * @param {number} [offset] the number of collections to skip
     * @param {string} [state] if specified, only get objects with this state
     * @param {boolean} [revoked] if true, get revoked objects
     * @param {versions} [&quot;all&quot; | &quot;latest&quot;] if &quot;all&quot;, get all versions of the collections. if &quot;latest&quot;, only get the latest version of each collection.
     * @param {boolean} [deprecated] if true, get deprecated objects
     * @param {boolean} [deserialize] if true, deserialize objects to full STIX objects
     * @returns {Observable&lt;any[]&gt;} observable of retrieved objects
     */
    public getAllObjects(attackIDs?: string[], limit?: number, offset?: number, state?: string, revoked?: boolean, deprecated?: boolean, deserialize?: boolean) {
        let query &#x3D; new HttpParams({encoder: new CustomEncoder()});
        // pagination
        if (limit) query &#x3D; query.set(&quot;limit&quot;, limit.toString());
        if (offset) query &#x3D; query.set(&quot;offset&quot;, offset.toString());
        if (limit || offset) query &#x3D; query.set(&quot;includePagination&quot;, &quot;true&quot;);
        // other properties
        if (attackIDs) {
            attackIDs.forEach(id &#x3D;&gt; query &#x3D; query.append(&quot;attackId&quot;, id));
        }
        if (state) query &#x3D; query.set(&quot;state&quot;, state);
        if (revoked) query &#x3D; query.set(&quot;includeRevoked&quot;, revoked ? &quot;true&quot; : &quot;false&quot;);
        if (deprecated) query &#x3D; query.set(&quot;includeDeprecated&quot;, deprecated ? &quot;true&quot; : &quot;false&quot;);
        return this.http.get(&#x60;${this.baseUrl}/attack-objects&#x60;, {params: query}).pipe(
            tap(results &#x3D;&gt; logger.log(&#x60;retrieved ATT&amp;CK objects&#x60;, results)), // on success, trigger the success notification
            map(results &#x3D;&gt; {
                if (!deserialize) return results; //skip deserialization if param not added
                let response &#x3D; results as any;
                if (limit || offset) { // returned a paginated
                    let data &#x3D; response.data as Array&lt;any&gt;;
                    data &#x3D; data.filter(y &#x3D;&gt; ![&quot;marking-definition&quot;, &quot;identity&quot;].includes(y.stix.type)).map(y &#x3D;&gt; {
                        if (y.stix.type &#x3D;&#x3D; &quot;malware&quot; || y.stix.type &#x3D;&#x3D; &quot;tool&quot;) return new Software(y.stix.type, y);
                        else return new stixTypeToClass[y.stix.type](y);
                    });
                    response.data &#x3D; data;
                    return response;
                } else { //returned a stixObject[]
                    return {
                        pagination: {
                            total: response.length,
                            limit: -1,
                            offset: -1
                        },
                        data: response.filter(y &#x3D;&gt; ![&quot;marking-definition&quot;, &quot;identity&quot;].includes(y.stix.type)).map(y &#x3D;&gt; {
                            if (y.stix.type &#x3D;&#x3D; &quot;malware&quot; || y.stix.type &#x3D;&#x3D; &quot;tool&quot;) return new Software(y.stix.type, y);
                            else return new stixTypeToClass[y.stix.type](y);
                        })
                    }
                }
            }),
            catchError(this.handleError_continue([])), // on error, trigger the error notification and continue operation without crashing (returns empty item)
            share() // multicast so that multiple subscribers don&#x27;t trigger the call twice. THIS MUST BE THE LAST LINE OF THE PIPE
        )
    }

    /**
     * Factory to create a new STIX get by ID function
     * @template T the type to get
     * @param {AttackType} attackType the type to get
     * @returns getter function
     */
    private getStixObjectFactory&lt;T extends StixObject&gt;(attackType: AttackType) {
        let attackClass &#x3D; attackTypeToClass[attackType];
        let plural &#x3D; attackTypeToPlural[attackType]
        return function&lt;P extends T&gt;(id: string, modified?: Date | string, versions&#x3D;&quot;latest&quot;, includeSubs?: boolean, retrieveContents?: boolean, retrieveDataComponents?: boolean): Observable&lt;P[]&gt; {
            let url &#x3D; &#x60;${this.baseUrl}/${plural}/${id}&#x60;;
            if (modified) {
                let modifiedString &#x3D; typeof(modified) &#x3D;&#x3D; &quot;string&quot;? modified : modified.toISOString();
                url +&#x3D; &#x60;/modified/${modifiedString}&#x60;;
            }
            let query &#x3D; new HttpParams();
            if (versions !&#x3D; &quot;latest&quot;) query &#x3D; query.set(&quot;versions&quot;, versions);
            if (attackType &#x3D;&#x3D; &quot;collection&quot; &amp;&amp; retrieveContents) query &#x3D; query.set(&quot;retrieveContents&quot;, &quot;true&quot;);
            if (attackType &#x3D;&#x3D; &quot;data-source&quot; &amp;&amp; retrieveDataComponents) query &#x3D; query.set(&quot;retrieveDataComponents&quot;, &quot;true&quot;);
            return this.http.get(url, {headers: this.headers, params: query}).pipe(
                tap(result &#x3D;&gt; logger.log(&#x60;retrieved ${attackType}&#x60;, result)), // on success, trigger the success notification
                map(result &#x3D;&gt; {
                    let x &#x3D; result as any;
                    if (Array.isArray(result) &amp;&amp; result.length &#x3D;&#x3D; 0) {
                        logger.warn(&quot;empty result&quot;)
                        return [];
                    }
                    if (!Array.isArray(result)) x &#x3D; [x];
                    return x.map(y &#x3D;&gt; {
                        if (y.stix.type &#x3D;&#x3D; &quot;malware&quot; || y.stix.type &#x3D;&#x3D; &quot;tool&quot;) return new Software(y.stix.type, y);
                        else return new attackClass(y);
                    });
                }),
                switchMap(result &#x3D;&gt; { // add sub-technique or parent-technique but only if it&#x27;s a technique
                    if (!includeSubs) return of(result);
                    let x &#x3D; result as any[];
                    if (x[0].attackType !&#x3D; &quot;technique&quot;) return of(result); //don&#x27;t transform non-techniques
                    let t &#x3D; x[0] as Technique;
                    if (t.is_subtechnique) { //add parent technique
                        return this.getRelatedTo({sourceRef: t.stixID, relationshipType: &quot;subtechnique-of&quot;}).pipe( // fetch from REST API
                            map(rel &#x3D;&gt; { //extract the parent from the relationship
                                let p &#x3D; rel as any;
                                if (!p || p.data.length &#x3D;&#x3D; 0) return null; // no parent technique
                                return new Technique(p.data[0].target_object); //transform it to a Technique
                            }),
                            map(parent &#x3D;&gt; { //add the parent to the sub-technique
                                let p &#x3D; parent as any;
                                t.parentTechnique &#x3D; p;
                                return [t];
                            }),
                            tap(result &#x3D;&gt; logger.log(&quot;fetched parent technique of&quot;, result, result[0][&quot;parentTechnique&quot;]))
                        );
                    } else { // add subtechniques
                        return this.getRelatedTo({targetRef: t.stixID, relationshipType: &quot;subtechnique-of&quot;}).pipe( // fetch from REST API
                            map(rel &#x3D;&gt; { //extract the sub-techniques from the relationships
                                let s &#x3D; rel as any;
                                return s.data.map(rel &#x3D;&gt; new Technique(rel.source_object)); //transform them to Techniques
                            }),
                            map(subs &#x3D;&gt; { //add the sub-techniques to the parent
                                let s &#x3D; subs as any[];
                                t.subTechniques &#x3D; s;
                                return [t];
                            }),
                            tap(result &#x3D;&gt; logger.log(&quot;fetched sub-techniques of&quot;, result, result[0][&quot;subTechniques&quot;]))
                        );
                    }
                }),
                switchMap(result &#x3D;&gt; { // fetch parent data source of data component
                    let x &#x3D; result as any[];
                    if (x[0].attackType !&#x3D; &quot;data-component&quot;) return of(result);
                    let d &#x3D; x[0] as DataComponent;
                    return this.getDataSource(d.data_source_ref).pipe( // fetch data source from REST API
                        map(data_source &#x3D;&gt; {
                            let ds &#x3D; data_source as DataSource[];
                            d.data_source &#x3D; ds[0];
                            return [d];
                        }),
                        tap(data_component &#x3D;&gt; logger.log(&quot;fetched data source of&quot;, data_component))
                    );
                }),
                catchError(this.handleError_continue([])), // on error, trigger the error notification and continue operation without crashing (returns empty item)
                share() // multicast so that multiple subscribers don&#x27;t trigger the call twice. THIS MUST BE THE LAST LINE OF THE PIPE
            )
        }
    }
    /**
     * Get a single technique by STIX ID
     * @param {string} id the object STIX ID
     * @param {Date} [modified] if specified, get the version modified at the given date
     * @param {versions} [string] default &quot;latest&quot;, if &quot;all&quot; returns all versions of the object instead of just the latest version. Incompatible with includeSubs
     * @param {includeSubs} [boolean] if true, include sub-techniques/parent-technique attached to the given object. Incompatible with versions&#x3D;&quot;all&quot;
     * @returns {Observable&lt;Technique&gt;} the object with the given ID and modified date
     */
    public get getTechnique() { return this.getStixObjectFactory&lt;Technique&gt;(&quot;technique&quot;); }
    /**
     * Get a single tactic by STIX ID
     * @param {string} id the object STIX ID
     * @param {Date} [modified] if specified, get the version modified at the given date
     * * @param {versions} [string] default &quot;latest&quot;, if &quot;all&quot; returns all versions of the object instead of just the latest version.
     * @returns {Observable&lt;Tactic&gt;} the object with the given ID and modified date
     */
    public get getTactic() { return this.getStixObjectFactory&lt;Tactic&gt;(&quot;tactic&quot;); }
    /**
     * Get a single group by STIX ID
     * @param {string} id the object STIX ID
     * @param {Date} [modified] if specified, get the version modified at the given date
     * * @param {versions} [string] default &quot;latest&quot;, if &quot;all&quot; returns all versions of the object instead of just the latest version.
     * @returns {Observable&lt;Group&gt;} the object with the given ID and modified date
     */
    public get getGroup() { return this.getStixObjectFactory&lt;Group&gt;(&quot;group&quot;); }
    /**
     * Get a single campaign by STIX ID
     * @param {string} id the object STIX ID
     * @param {Date} [modified] if specified, get the version modified at the given date
     * * @param {versions} [string] default &quot;latest&quot;, if &quot;all&quot; returns all versions of the object instead of just the latest version.
     * @returns {Observable&lt;Campaign&gt;} the object with the given ID and modified date
     */
    public get getCampaign() { return this.getStixObjectFactory&lt;Campaign&gt;(&quot;campaign&quot;); }
    /**
     * Get a single software by STIX ID
     * @param {string} id the object STIX ID
     * @param {Date} [modified] if specified, get the version modified at the given date
     * @param {versions} [string] default &quot;latest&quot;, if &quot;all&quot; returns all versions of the object instead of just the latest version.
     * @returns {Observable&lt;Software&gt;} the object with the given ID and modified date
     */
    public get getSoftware() { return this.getStixObjectFactory&lt;Software&gt;(&quot;software&quot;); }
    /**
     * Get a single mitigation by STIX ID
     * @param {string} id the object STIX ID
     * @param {Date} [modified] if specified, get the version modified at the given date
     * @param {versions} [string] default &quot;latest&quot;, if &quot;all&quot; returns all versions of the object instead of just the latest version.
     * @returns {Observable&lt;Mitigation&gt;} the object with the given ID and modified date
     */
    public get getMitigation() { return this.getStixObjectFactory&lt;Mitigation&gt;(&quot;mitigation&quot;); }
    /**
     * Get a single data source by STIX ID
     * @param {string} id the object STIX ID
     * @param {Date} [modified] if specified, get the version modified at the given date
     * @param {versions} [string] default &quot;latest&quot;, if &quot;all&quot; returns all versions of the object instead of just the latest version.
     * @param {retrieveDataComponents} [boolean] if true, include data components with a reference to the given object. Incompatible with versions&#x3D;&quot;all&quot;
     * @returns {Observable&lt;DataSource&gt;} the object with the given ID and modified date
     */
    public get getDataSource() { return this.getStixObjectFactory&lt;DataSource&gt;(&quot;data-source&quot;); }
    /**
     * Get a single data component by STIX ID
     * @param {string} id the object STIX ID
     * @param {Date} [modified] if specified, get the version modified at the given date
     * @param {versions} [string] default &quot;latest&quot;, if &quot;all&quot; returns all versions of the object instead of just the latest version.
     * @returns {Observable&lt;DataComponent&gt;} the object with the given ID and modified date
     */
    public get getDataComponent() { return this.getStixObjectFactory&lt;DataComponent&gt;(&quot;data-component&quot;); }
    /**
     * Get a single matrix by STIX ID
     * @param {string} id the object STIX ID
     * @param {Date} [modified] if specified, get the version modified at the given date
     * @param {versions} [string] default &quot;latest&quot;, if &quot;all&quot; returns all versions of the object instead of just the latest version.
     * @returns {Observable&lt;Matrix&gt;} the object with the given ID and modified date
     */
    public get getMatrix() { return this.getStixObjectFactory&lt;Matrix&gt;(&quot;matrix&quot;); }
    /**
     * Get a single collection by STIX ID
     * @param {string} id the object STIX ID
     * @param {Date} [modified] if specified, get the version modified at the given date
     * @param {versions} [string] default &quot;latest&quot;, if &quot;all&quot; returns all versions of the object instead of just the latest version.
     * @returns {Observable&lt;Collection&gt;} the object with the given ID and modified date
     */
    public get getCollection() { return this.getStixObjectFactory&lt;Collection&gt;(&quot;collection&quot;); }
    /**
     * Get a single note by STIX ID
     * @param {string} id the object STIX ID
     * @param {Date} [modified] if specified, get the version modified at the given date
     * @param {versions} [string] default &quot;latest&quot;, if &quot;all&quot; returns all versions of the object instead of just the latest version.
     * @returns {Observable&lt;Note&gt;} the object with the given ID and modified date
     */
    public get getNote() { return this.getStixObjectFactory&lt;Note&gt;(&quot;note&quot;); }
    /**
     * Get a single identity by STIX ID
     * @param {string} id the object STIX ID
     * @param {Date} [modified] if specified, get the version modified at the given date
     * @param {versions} [string] default &quot;latest&quot;, if &quot;all&quot; returns all versions of the object instead of just the latest version.
     * @returns {Observable&lt;Identity&gt;} the object with the given ID and modified date
     */
     public get getIdentity() { return this.getStixObjectFactory&lt;Identity&gt;(&quot;identity&quot;); }
    /**
     * Get a single marking definition by STIX ID
     * @param {string} id the object STIX ID
     * @returns {Observable&lt;MarkingDefinition&gt;} the object with the given ID
     */
     public get getMarkingDefinition() { return this.getStixObjectFactory&lt;MarkingDefinition&gt;(&quot;marking-definition&quot;)}
    /**
     * Factory to create a new STIX object creator (POST) function
     * @template T the type to create
     * @param {AttackType} attackType tehe type to create
     * @returns creator (POST) function
     */
    private postStixObjectFactory&lt;T extends StixObject&gt;(attackType: AttackType) {
        let attackClass &#x3D; attackTypeToClass[attackType];
        let plural &#x3D; attackTypeToPlural[attackType];
        return function&lt;P extends T&gt;(object: P): Observable&lt;P&gt; {
            let url &#x3D; &#x60;${this.baseUrl}/${plural}&#x60;;
            return this.http.post(url, object.serialize(), {headers: this.headers}).pipe(
                tap(this.handleSuccess(&#x60;${this.getObjectName(object)} saved&#x60;)),
                map(result &#x3D;&gt; {
                    let x &#x3D; result as any;
                    if (x.stix.type &#x3D;&#x3D; &quot;malware&quot; || x.stix.type &#x3D;&#x3D; &quot;tool&quot;) return new Software(x.stix.type, x);
                    else return new attackClass(x);
                }),
                catchError(this.handleError_raise()),
                share() // multicast so that multiple subscribers don&#x27;t trigger the call twice. THIS MUST BE THE LAST LINE OF THE PIPE
            )
        }
    }

    /**
     * POST (create) a new technique
     * @param {Technique} object the object to create
     * @returns {Observable&lt;Technique&gt;} the created object
     */
    public get postTechnique() { return this.postStixObjectFactory&lt;Technique&gt;(&quot;technique&quot;); }
    /**
     * POST (create) a new tactic
     * @param {Tactic} object the object to create
     * @returns {Observable&lt;Tactic&gt;} the created object
     */
    public get postTactic() { return this.postStixObjectFactory&lt;Tactic&gt;(&quot;tactic&quot;); }
    /**
     * POST (create) a new group
     * @param {Group} object the object to create
     * @returns {Observable&lt;Group&gt;} the created object
     */
    public get postGroup() { return this.postStixObjectFactory&lt;Group&gt;(&quot;group&quot;); }
    /**
     * POST (create) a new campaign
     * @param {Campaign} object the object to create
     * @returns {Observable&lt;Campaign&gt;} the created object
     */
    public get postCampaign() { return this.postStixObjectFactory&lt;Campaign&gt;(&quot;campaign&quot;); }
    /**
     * POST (create) a new software
     * @param {Software} object the object to create
     * @returns {Observable&lt;Software&gt;} the created object
     */
    public get postSoftware() { return this.postStixObjectFactory&lt;Software&gt;(&quot;software&quot;); }
    /**
     * POST (create) a new mitigation
     * @param {Mitigation} object the object to create
     * @returns {Observable&lt;Mitigation&gt;} the created object
     */
    public get postMitigation() { return this.postStixObjectFactory&lt;Mitigation&gt;(&quot;mitigation&quot;); }
    /**
     * POST (create) a new data source
     * @param {DataSource} object the object to create
     * @returns {Observable&lt;DataSource&gt;} the created object
     */
    public get postDataSource() { return this.postStixObjectFactory&lt;DataSource&gt;(&quot;data-source&quot;); }
    /**
     * POST (create) a new data component
     * @param {DataComponent} object the object to create
     * @returns {Observable&lt;DataComponent&gt;} the created object
     */
    public get postDataComponent() { return this.postStixObjectFactory&lt;DataComponent&gt;(&quot;data-component&quot;); }
    /**
     * POST (create) a new matrix
     * @param {Matrix} object the object to create
     * @returns {Observable&lt;Matrix&gt;} the created object
     */
    public get postMatrix() { return this.postStixObjectFactory&lt;Matrix&gt;(&quot;matrix&quot;); }
    /**
     * POST (create) a new relationship
     * @param {Relationship} object the object to create
     * @returns {Observable&lt;Relationship&gt;} the created object
     */
    public get postRelationship() { return this.postStixObjectFactory&lt;Relationship&gt;(&quot;relationship&quot;); }
    /**
     * POST (create) a new relationship
     * @param {MarkingDefinition} object the object to create
     * @returns {Observable&lt;MarkingDefinition&gt;} the created object
     */
     public get postMarkingDefinition() { return this.postStixObjectFactory&lt;MarkingDefinition&gt;(&quot;marking-definition&quot;); }
    /**
     * POST (create) a new note
     * @param {Note} object the object to create
     * @returns {Observable&lt;Note&gt;} the created object
     */
    public get postNote() { return this.postStixObjectFactory&lt;Note&gt;(&quot;note&quot;); }
    /**
     * POST (create) a new collection
     * @param {Collection} object the object to create
     * @returns {Observable&lt;Collection&gt;} the created object
     */
    public get postCollection() { return this.postStixObjectFactory&lt;Collection&gt;(&quot;collection&quot;); }
    /**
     * POST (create) a new identity
     * @param {Identity} object the object to create
     * @returns {Observable&lt;Identity&gt;} the created object
     */
     public get postIdentity() { return this.postStixObjectFactory&lt;Identity&gt;(&quot;identity&quot;); }

    /**
     * Factory to create a new STIX put (update) function
     * @template T the type to put
     * @param {AttackType} attackType the type to put
     * @returns put function
     */
    private putStixObjectFactory&lt;T extends StixObject&gt;(attackType: AttackType) {
        let attackClass &#x3D; attackTypeToClass[attackType];
        let plural &#x3D; attackTypeToPlural[attackType];
        return function&lt;P extends T&gt;(object: T, modified?: Date): Observable&lt;P&gt; {
            if (!modified) modified &#x3D; object.modified; //infer modified from STIX object modified date
            let url &#x3D; &#x60;${this.baseUrl}/${plural}/${object.stixID}/modified/${modified}&#x60;;
            return this.http.put(url, object.serialize(), {headers: this.headers}).pipe(
                tap(this.handleSuccess(&#x60;${this.getObjectName(object)} saved&#x60;)),
                map(result &#x3D;&gt; {
                    let x &#x3D; result as any;
                    if (x.stix.type &#x3D;&#x3D; &quot;malware&quot; || x.stix.type &#x3D;&#x3D; &quot;tool&quot;) return new Software(x.stix.type, x);
                    else return new attackClass(x);
                }),
                catchError(this.handleError_raise()),
                share() // multicast so that multiple subscribers don&#x27;t trigger the call twice. THIS MUST BE THE LAST LINE OF THE PIPE
            )
        }
    }

    /**
     * PUT (update) a technique
     * @param {Technique} object the object to update
     * @param {Date} [modified] optional, the modified date to overwrite. If omitted, uses the modified field of the object
     * @returns {Observable&lt;Technique&gt;} the updated object
     */
    public get putTechnique() { return this.putStixObjectFactory&lt;Technique&gt;(&quot;technique&quot;); }
    /**
     * PUT (update) a tactic
     * @param {Tactic} object the object to update
     * @param {Date} [modified] optional, the modified date to overwrite. If omitted, uses the modified field of the object
     * @returns {Observable&lt;Tactic&gt;} the updated object
     */
    public get putTactic() { return this.putStixObjectFactory&lt;Tactic&gt;(&quot;tactic&quot;); }
    /**
     * PUT (update) a group
     * @param {Group} object the object to update
     * @param {Date} [modified] optional, the modified date to overwrite. If omitted, uses the modified field of the object
     * @returns {Observable&lt;Group&gt;} the updated object
     */
    public get putGroup() { return this.putStixObjectFactory&lt;Group&gt;(&quot;group&quot;); }
    /**
     * PUT (update) a campaign
     * @param {Campaign} object the object to update
     * @param {Date} [modified] optional, the modified date to overwrite. If omitted, uses the modified field of the object
     * @returns {Observable&lt;Campaign&gt;} the updated object
     */
    public get putCampaign() { return this.putStixObjectFactory&lt;Campaign&gt;(&quot;campaign&quot;); }
    /**
     * PUT (update) a software
     * @param {Software} object the object to update
     * @param {Date} [modified] optional, the modified date to overwrite. If omitted, uses the modified field of the object
     * @returns {Observable&lt;Software&gt;} the updated object
     */
    public get putSoftware() { return this.putStixObjectFactory&lt;Software&gt;(&quot;software&quot;); }
    /**
     * PUT (update) a mitigation
     * @param {Mitigation} object the object to update
     * @param {Date} [modified] optional, the modified date to overwrite. If omitted, uses the modified field of the object
     * @returns {Observable&lt;Mitigation&gt;} the updated object
     */
    public get putMitigation() { return this.putStixObjectFactory&lt;Mitigation&gt;(&quot;mitigation&quot;); }
    /**
     * PUT (update) a data source
     * @param {DataSource} object the object to update
     * @param {Date} [modified] optional, the modified date to overwrite. If omitted, uses the modified field of the object
     * @returns {Observable&lt;DataSource&gt;} the updated object
     */
    public get putDataSource() { return this.putStixObjectFactory&lt;DataSource&gt;(&quot;data-source&quot;); }
    /**
     * PUT (update) a data component
     * @param {DataComponent} object the object to update
     * @param {Date} [modified] optional, the modified date to overwrite. If omitted, uses the modified field of the object
     * @returns {Observable&lt;DataComponent&gt;} the updated object
     */
    public get putDataComponent() { return this.putStixObjectFactory&lt;DataComponent&gt;(&quot;data-component&quot;); }
    /**
     * PUT (update) a matrix
     * @param {Matrix} object the object to update
     * @param {Date} [modified] optional, the modified date to overwrite. If omitted, uses the modified field of the object
     * @returns {Observable&lt;Matrix&gt;} the updated object
     */
    public get putMatrix() { return this.putStixObjectFactory&lt;Matrix&gt;(&quot;matrix&quot;); }
    /**
     * PUT (update) a relationship
     * @param {Relationship} object the object to update
     * @param {Date} [modified] optional, the modified date to overwrite. If omitted, uses the modified field of the object
     * @returns {Observable&lt;Relationship&gt;} the updated object
     */
    public get putRelationship() { return this.putStixObjectFactory&lt;Relationship&gt;(&quot;relationship&quot;); }
    /**
     * PUT (update) a note
     * @param {Note} object the object to update
     * @param {Date} [modified] optional, the modified date to overwrite. If omitted, uses the modified field of the object
     * @returns {Observable&lt;Note&gt;} the updated object
     */
    public get putNote() { return this.putStixObjectFactory&lt;Note&gt;(&quot;note&quot;); }
    /**
     * PUT (update) an identity
     * @param {Identity} object the object to update
     * @param {Date} [modified] optional, the modified date to overwrite. If omitted, uses the modified field of the object
     * @returns {Observable&lt;Identity&gt;} the updated object
     */
    public get putIdentity() { return this.putStixObjectFactory&lt;Identity&gt;(&quot;identity&quot;); }


    private deleteStixObjectFactory(attackType: AttackType) {
        let plural &#x3D; attackTypeToPlural[attackType];
        return function(id: string, modified: Date): Observable&lt;{}&gt; {
            let modifiedStix &#x3D; modified.toISOString();
            let url &#x3D; &#x60;${this.baseUrl}/${plural}/${id}/modified/${modifiedStix}&#x60;;
            return this.http.delete(url).pipe(
                tap(this.handleSuccess(&#x60;${attackType} deleted&#x60;)),
                catchError(this.handleError_raise()),
                share() // multicast so that multiple subscribers don&#x27;t trigger the call twice. THIS MUST BE THE LAST LINE OF THE PIPE
            );
        }
    }

    /**
     * DELETE a technique
     * @param {string} id the STIX ID of the object to delete
     * @param {Date} modified the modified date of the version to delete
     * @returns {Observable&lt;{}&gt;} observable of the response body
     */
    public get deleteTechnique() { return this.deleteStixObjectFactory(&quot;technique&quot;); }
    /**
     * DELETE a tactic
     * @param {string} id the STIX ID of the object to delete
     * @param {Date} modified the modified date of the version to delete
     * @returns {Observable&lt;{}&gt;} observable of the response body
     */
    public get deleteTactic() { return this.deleteStixObjectFactory(&quot;tactic&quot;); }
    /**
     * DELETE a group
     * @param {string} id the STIX ID of the object to delete
     * @param {Date} modified the modified date of the version to delete
     * @returns {Observable&lt;{}&gt;} observable of the response body
     */
    public get deleteGroup() { return this.deleteStixObjectFactory(&quot;group&quot;); }
    /**
     * DELETE a campaign
     * @param {string} id the STIX ID of the object to delete
     * @param {Date} modified the modified date of the version to delete
     * @returns {Observable&lt;{}&gt;} observable of the response body
     */
    public get deleteCampaign() { return this.deleteStixObjectFactory(&quot;campaign&quot;); }
    /**
     * DELETE a software
     * @param {string} id the STIX ID of the object to delete
     * @param {Date} modified the modified date of the version to delete
     * @returns {Observable&lt;{}&gt;} observable of the response body
     */
    public get deleteSoftware() { return this.deleteStixObjectFactory(&quot;software&quot;); }
    /**
     * DELETE a mitigation
     * @param {string} id the STIX ID of the object to delete
     * @param {Date} modified the modified date of the version to delete
     * @returns {Observable&lt;{}&gt;} observable of the response body
     */
    public get deleteMitigation() { return this.deleteStixObjectFactory(&quot;mitigation&quot;); }
    /**
     * DELETE a data source
     * @param {string} id the STIX ID of the object to delete
     * @param {Date} modified the modified date of the version to delete
     * @returns {Observable&lt;{}&gt;} observable of the response body
     */
    public get deleteDataSource() { return this.deleteStixObjectFactory(&quot;data-source&quot;); }
    /**
     * DELETE a data component
     * @param {string} id the STIX ID of the object to delete
     * @param {Date} modified the modified date of the version to delete
     * @returns {Observable&lt;{}&gt;} observable of the response body
     */
    public get deleteDataComponent() { return this.deleteStixObjectFactory(&quot;data-component&quot;); }
    /**
     * DELETE a matrix
     * @param {string} id the STIX ID of the object to delete
     * @param {Date} modified The modified date of the version to delete
     * @returns {Observable&lt;{}&gt;} observable of the response body
     */
    public get deleteMatrix() { return this.deleteStixObjectFactory(&quot;matrix&quot;); }
    /**
     * DELETE a collection
     * @param {string} id the STIX ID of the object to delete
     * @param {Date} modified The modified date of the version to delete
     * @returns {Observable&lt;{}&gt;} observable of the response body
     */
    public get deleteCollection() { return this.deleteStixObjectFactory(&quot;collection&quot;); }
    /**
     * DELETE a note
     * @param {string} id the STIX ID of the object to delete
     * @param {Date} modified The modified date of the version to delete
     * @returns {Observable&lt;{}&gt;} observable of the response body
     */
    public deleteNote(id: string) {
        return this.http.delete(&#x60;${this.baseUrl}/notes/${id}&#x60;).pipe(
            tap(this.handleSuccess(&quot;note removed&quot;)),
            catchError(this.handleError_raise()),
            share()
        )
    }

    //   ___ ___ _      _ _____ ___ ___  _  _ ___ _  _ ___ ___  ___
    //  | _ \ __| |    /_\_   _|_ _/ _ \| \| / __| || |_ _| _ \/ __|
    //  |   / _|| |__ / _ \| |  | | (_) | .&#x60; \__ \ __ || ||  _/\__ \
    //  |_|_\___|____/_/ \_\_| |___\___/|_|\_|___/_||_|___|_|  |___/
    //

    /**
     * Get relationships. Note: pass in args in an object
     *
     * @param {string} [sourceRef] STIX id of referenced object. Only retrieve relationships that reference this object in the source_ref property.
     * @param {string} [targetRef] STIX id of referenced object. Only retrieve relationships that reference this object in the target_ref property.
     * @param {string} [sourceOrTargetRef] STIX id of referenced object. Only retrieve relationships that reference this object in the target_ref or source_ref property.
     * @param {string} [relationshipType] Only retrieve relationships that have a matching relationship_type.
     * @param {string} [sourceType] retrieve objects where the source object is this ATT&amp;CK type
     * @param {string} [targetType] retrieve objects where the source object is this ATT&amp;CK type
     * @param {number} [limit] The number of relationships to retrieve.
     * @param {number} [offset] The number of relationships to skip.
     * @param {boolean} [includeDeprecated] if true, include deprecated relationships.
     * @param {&quot;all&quot; | &quot;latest&quot;} [versions] if &quot;all&quot;, get all versions of the relationships, otherwise only get the latest versions
     * @param {string[]} [excludeSourceRefs] if specified, exclude source refs which are found in this array
     * @param {string[]} [excludeTargetRefs] if specified, exclude target refs which are found in this array
     * @returns {Observable&lt;Paginated&gt;} paginated data of the relationships
     */
    public getRelatedTo(args: {sourceRef?: string, targetRef?: string, sourceOrTargetRef?: string, sourceType?: AttackType, targetType?: AttackType, relationshipType?: string, excludeSourceRefs?: string[], excludeTargetRefs?: string[], limit?: number, offset?: number, includeDeprecated?: boolean, versions?: &quot;all&quot; | &quot;latest&quot;}): Observable&lt;Paginated&lt;StixObject&gt;&gt; {
        let query &#x3D; new HttpParams();

        if (args.sourceRef) query &#x3D; query.set(&quot;sourceRef&quot;, args.sourceRef);
        if (args.targetRef) query &#x3D; query.set(&quot;targetRef&quot;, args.targetRef);

        if (args.sourceType) query &#x3D; query.set(&quot;sourceType&quot;, args.sourceType);
        if (args.targetType) query &#x3D; query.set(&quot;targetType&quot;, args.targetType);

        if (args.sourceOrTargetRef) query &#x3D; query.set(&quot;sourceOrTargetRef&quot;, args.sourceOrTargetRef);

        if (args.relationshipType) query &#x3D; query.set(&quot;relationshipType&quot;, args.relationshipType);

        if (args.includeDeprecated) query &#x3D; query.set(&quot;includeDeprecated&quot;, args.includeDeprecated ? &quot;true&quot; : &quot;false&quot;);

        if (args.versions) query &#x3D; query.set(&quot;versions&quot;, args.versions);

        if (args.limit) query &#x3D; query.set(&quot;limit&quot;, args.limit.toString());
        if (args.offset) query &#x3D; query.set(&quot;offset&quot;, args.offset.toString());
        if (args.limit || args.offset) query &#x3D; query.set(&quot;includePagination&quot;, &quot;true&quot;);
        let url &#x3D; &#x60;${this.baseUrl}/relationships&#x60;
        return this.http.get(url, {params: query}).pipe(
            tap(results &#x3D;&gt; logger.log(&quot;retrieved relationships&quot;, results)),
            map(results &#x3D;&gt; {
                if (!args.excludeSourceRefs &amp;&amp; !args.excludeTargetRefs) return results; // only filter if params are present
                let response &#x3D; results as any;
                if (args.limit || args.offset) { // returned a paginated
                    let pre_filter &#x3D; response.data.length;
                    if (args.excludeSourceRefs) response.data &#x3D; response.data.filter((d) &#x3D;&gt; !args.excludeSourceRefs.includes(d.stix.source_ref))
                    if (args.excludeTargetRefs) response.data &#x3D; response.data.filter((d) &#x3D;&gt; !args.excludeTargetRefs.includes(d.stix.target_ref))
                    logger.log(&quot;filtered&quot;, pre_filter - response.data.length, &quot;results by ID&quot;)
                    return response;
                } else { //returned a stixObject[]
                    let pre_filter &#x3D; response.length;
                    if (args.excludeSourceRefs) response &#x3D; response.filter((d) &#x3D;&gt; !args.excludeSourceRefs.includes(d.stix.source_ref))
                    if (args.excludeTargetRefs) response &#x3D; response.filter((d) &#x3D;&gt; !args.excludeTargetRefs.includes(d.stix.target_ref))
                    logger.log(&quot;filtered&quot;, pre_filter - response.length, &quot;results by ID&quot;)
                    return response;
                }
            }),
            map(results &#x3D;&gt; {
                let response &#x3D; results as any;
                if (args.limit || args.offset) { //returned paginated
                    let data &#x3D; response.data as Array&lt;any&gt;;
                    data &#x3D; data.map(y &#x3D;&gt; new Relationship(y));
                    response.data &#x3D; data;
                    return response;
                } else { //returned StixObject[]
                    return {
                        pagination: {
                            total: response.length,
                            limit: -1,
                            offset: -1
                        },
                        data: response.map(y &#x3D;&gt; new Relationship(y))
                    }
                }
            }),
            catchError(this.handleError_continue([])),
            share()
        )
    }

    /**
     * Get all objects related to a data source
     * @param id the STIX ID of the data source
     * @returns list of data components related to the data source along with the data components&#x27; relationships with techniques
     */
    public getAllRelatedToDataSource(id: string): Observable&lt;StixObject[]&gt; {
        let dataComponents$ &#x3D; this.getAllDataComponents();
        return dataComponents$.pipe(
            map(result &#x3D;&gt; { // get related data component objects
                let dataComponents &#x3D; result.data as DataComponent[];
                return dataComponents.filter(d &#x3D;&gt; d.data_source_ref &#x3D;&#x3D; id);
            }),
            mergeMap(dataComponents &#x3D;&gt; { // get relationships for each data component
                let relatedTo &#x3D; dataComponents.map(dc &#x3D;&gt; this.getRelatedTo({sourceOrTargetRef: dc.stixID}));
                if (!relatedTo.length) return of(dataComponents);
                return forkJoin(relatedTo).pipe(
                    map(relationships &#x3D;&gt; {
                        let all_results: StixObject[] &#x3D; [];
                        for(let relationship_result of relationships) {
                            all_results &#x3D; all_results.concat(relationship_result.data)
                        }
                        return all_results.concat(dataComponents);
                    })
                );
            }),
            catchError(this.handleError_continue([])),
            share()
        );
    }

    /**
     * Get all techniques referencing the given tactic
     * @param {string} tactic_id the stix id of the tactic
     * @param {Date} modified the modified date of the tactic
     * @returns {Technique[]} a list of techniques that reference the tactic
     */
    public getTechniquesInTactic(tactic_id: string, modified: Date): Observable&lt;Technique[]&gt; {
        let url &#x3D; &#x60;${this.baseUrl}/tactics/${tactic_id}/modified/${modified.toISOString()}/techniques&#x60;;
        return this.http.get(url).pipe(
            tap(results &#x3D;&gt; logger.log(&quot;retrieved techniques&quot;, results)),
            map(response &#x3D;&gt; {
                let data &#x3D; response as Array&lt;any&gt;;
                let techniques: Technique[] &#x3D; data.map(sdo &#x3D;&gt; {
                    return new Technique(sdo);
                });
                return techniques;
            }),
            catchError(this.handleError_continue([])),
            share()
        )
    }

    /**
     * Get all tactics referenced by the given technique
     * @param {string} technique_id the stix id of the technique
     * @param {Date} modified the modified date of the technique
     * @returns {Tactic[]} a list of tactics that are referenced by the technique
     */
    public getTacticsRelatedToTechnique(technique_id: string, modified: Date): Observable&lt;Tactic[]&gt; {
        let url &#x3D; &#x60;${this.baseUrl}/techniques/${technique_id}/modified/${modified.toISOString()}/tactics&#x60;;
        return this.http.get(url).pipe(
            tap(results &#x3D;&gt; logger.log(&quot;retrieved tactics&quot;, results)),
            map(response &#x3D;&gt; {
                let data &#x3D; response as Array&lt;any&gt;;
                let tactics: Tactic[] &#x3D; data.map(sdo &#x3D;&gt; {
                    return new Tactic(sdo);
                });
                return tactics;
            }),
            catchError(this.handleError_continue([])),
            share()
        )
    }

    //   ___ ___ ___ ___ ___ ___ _  _  ___ ___ ___
    //  | _ \ __| __| __| _ \ __| \| |/ __| __/ __|
    //  |   / _|| _|| _||   / _|| .&#x60; | (__| _|\__ \
    //  |_|_\___|_| |___|_|_\___|_|\_|\___|___|___/

    /**
     * get all external references
     * @param {number} [limit] the number of references to retrieve
     * @param {number} [offset] the number of references to skip
     * @param {string} [search] Only return references where the provided search text occurs in the description or url. The search is case-insensitive.
     * @returns {Observable&lt;Paginated&gt;} paginated data for external references
     */
    public getAllReferences(limit?: number, offset?: number, search?: string): Observable&lt;Paginated&lt;ExternalReference&gt;&gt; {
        let url &#x3D; &#x60;${this.baseUrl}/references&#x60;;
        // parse params into query string
        let query &#x3D; new HttpParams({encoder: new CustomEncoder()});
        // pagination
        if (limit) query &#x3D; query.set(&quot;limit&quot;, limit.toString());
        if (offset) query &#x3D; query.set(&quot;offset&quot;, offset.toString());
        if (search) query &#x3D; query.set(&quot;search&quot;, search);
        /*if (limit || offset) */ query &#x3D; query.set(&quot;includePagination&quot;, &quot;true&quot;);
        return this.http.get&lt;Paginated&lt;ExternalReference&gt;&gt;(url, {params: query}).pipe(
            tap(results &#x3D;&gt; logger.log(&quot;retrieved references&quot;, results)),
            catchError(this.handleError_continue&lt;Paginated&lt;ExternalReference&gt;&gt;({data: [], pagination: {total: 0, limit: 0, offset: 0}})), // on error, trigger the error notification and continue operation without crashing (returns empty item)
            share() // multicast so that multiple subscribers don&#x27;t trigger the call twice. THIS MUST BE THE LAST LINE OF THE PIPE
        )
    }

    /**
     * Get a single reference by source name
     * @param {string} source_name the reference&#x27;s source_name identifier
     * @returns {Observable&lt;ExternalReference&gt;} the external reference with the given source_name
     */
    public getReference(source_name: string): Observable&lt;ExternalReference&gt; {
        let url &#x3D; &#x60;${this.baseUrl}/references&#x60;;
        // parse params into query string
        let query &#x3D; new HttpParams();
        query &#x3D; query.set(&quot;sourceName&quot;, source_name);
        return this.http.get&lt;ExternalReference&gt;(url, {params: query}).pipe(
            tap(results &#x3D;&gt; logger.log(&quot;retrieved reference&quot;, results)),
            catchError(this.handleError_continue&lt;ExternalReference&gt;()), // on error, trigger the error notification and continue operation without crashing (returns empty item)
            share() // multicast so that multiple subscribers don&#x27;t trigger the call twice. THIS MUST BE THE LAST LINE OF THE PIPE
        )
    }

    /**
     * Create an external reference
     * @param {ExternalReference} reference the reference to create
     * @returns {Observable&lt;ExternalReference&gt;} the created reference
     */
    public postReference(reference: ExternalReference): Observable&lt;ExternalReference&gt; {
        let url &#x3D; &#x60;${this.baseUrl}/references&#x60;;
        return this.http.post&lt;ExternalReference&gt;(url, reference).pipe(
            tap(this.handleSuccess(&#x60;${reference.source_name} saved&#x60;)),
            catchError(this.handleError_raise&lt;ExternalReference&gt;()), // on error, trigger the error notification and continue operation without crashing (returns empty item)
            share() // multicast so that multiple subscribers don&#x27;t trigger the call twice. THIS MUST BE THE LAST LINE OF THE PIPE
        )
    }

    /**
     * Update an external reference
     * @param {ExternalReference} reference the reference to update
     * @returns {Observable&lt;ExternalReference&gt;} the updated reference
     */
    public putReference(reference: ExternalReference): Observable&lt;ExternalReference&gt; {
        let url &#x3D; &#x60;${this.baseUrl}/references&#x60;;
        return this.http.put&lt;ExternalReference&gt;(url, reference).pipe(
            tap(this.handleSuccess(&#x60;${reference.source_name} saved&#x60;)),
            catchError(this.handleError_raise&lt;ExternalReference&gt;()), // on error, trigger the error notification and continue operation without crashing (returns empty item)
            share() // multicast so that multiple subscribers don&#x27;t trigger the call twice. THIS MUST BE THE LAST LINE OF THE PIPE
        )
    }

    //    ___ ___  _    _    ___ ___ _____ ___ ___  _  _     _   ___ ___ ___
    //   / __/ _ \| |  | |  | __/ __|_   _|_ _/ _ \| \| |   /_\ | _ \_ _/ __|
    //  | (_| (_) | |__| |__| _| (__  | |  | | (_) | .&#x60; |  / _ \|  _/| |\__ \
    //   \___\___/|____|____|___\___| |_| |___\___/|_|\_| /_/ \_\_| |___|___/
    //

    /**
     * POST a collection bundle (including a collection SDO and the objects to which it refers) to the back-end
     * @param {*} collectionBundle the STIX bundle to write
     * @param {boolean} [preview] if true, preview the results of the import without actually committing the import
     * @param {boolean} [force] if true, force import the collection
     * @param {boolean} [suppressErrors] if true, suppress the error snackbar
     * @returns {Observable&lt;Collection&gt;} collection object marking the results of the import
     */
    public postCollectionBundle(collectionBundle: any, preview: boolean &#x3D; false, force: boolean &#x3D; false, suppressErrors: boolean &#x3D; false): Observable&lt;Collection&gt; {
        // add query params for preview
        let query &#x3D; new HttpParams();
        if (preview) query &#x3D; query.set(&quot;previewOnly&quot;, &quot;true&quot;);
        if (force) query &#x3D; query.set(&quot;forceImport&quot;, &quot;all&quot;);
        // perform the request
        return this.http.post(&#x60;${this.baseUrl}/collection-bundles&#x60;, collectionBundle, {params: query}).pipe(
            tap(result &#x3D;&gt; {
                if (preview) logger.log(&quot;previewed collection import&quot;, result);
                else this.handleSuccess(&quot;imported collection&quot;)(result);
            }),
            map(result &#x3D;&gt; {
                return new Collection(result);
            }),
            catchError(this.handleError_raise&lt;Collection&gt;(!suppressErrors)),
            share()
        )
    }

    /**
     * Preview a collection bundle.
     * POST the collection bundle to the back end to retrieve a preview of the import results. A second POST
     * call will occur (with ?forceImport&#x3D;&#x27;all&#x27;) if the first POST call results in an overridable import error.
     * This is done in order to view the import errors alongside a preview of the import results.
     * @param collectionBundle the STIX bundle to preview
     * @returns {Observable&lt;any&gt;} the collection object and any import errors as result of the preview import
     */
    public previewCollectionBundle(collectionBundle: any): Observable&lt;any&gt; {
        // perform preview request
        return this.postCollectionBundle(collectionBundle, true, false, true).pipe(
            map(result &#x3D;&gt; {
                return {error: undefined, preview: result};
            }),
            catchError(err &#x3D;&gt; {
                // check if import can be forced
                if (this.cannotForceImport(err)) {
                    return of({error: err.error, preview: undefined});
                }
                // force request
                return this.postCollectionBundle(collectionBundle, true, true, true).pipe(
                    map(force_result &#x3D;&gt; {
                        return {error: err.error, preview: force_result};
                    }),
                    catchError(this.handleError_raise&lt;Collection&gt;())
                )
            }),
            share()
        );
    }

    /**
     * Determine if the user cannot force import a collection when the post collection call fails.
     * Users cannot force an import when:
     *   1. the collection bundle has more than one collection object
     *   2. the collection bundle does not have a collection object
     *   3. the collection is badly formatted
     *   4. the collection contains duplicate objects
     * @param err the resulting error from previewing the collection
     * @returns true if the user cannot force import the collection; false otherwise
     */
    private cannotForceImport(err: any): boolean {
        if (err.status &#x3D;&#x3D; &quot;400&quot;) {
            let bundleErrors &#x3D; err.error.bundleErrors;
            let objectErrors &#x3D; err.error.objectErrors.summary;
            if (bundleErrors.noCollection || bundleErrors.moreThanOneCollection || bundleErrors.badlyFormattedCollection || objectErrors.duplicateObjectInBundleCount) {
                return true;
            }
            return false;
        }
        return true;
    }

    /**
     * Get a collection bundle
     * @param {string} id STIX ID of collection
     * @param {Date} modified modified date of collection
     * @param {boolean} includeNotes if true, include relevant Note objects
     * @returns {Observable&lt;any&gt;} collection STIX bundle
     */
    public getCollectionBundle(id: string, modified: Date, includeNotes?: boolean): Observable&lt;any&gt; {
        let query &#x3D; new HttpParams();
        query &#x3D; query.set(&quot;collectionId&quot;, id);
        query &#x3D; query.set(&quot;collectionModified&quot;, modified.toISOString());
        if (includeNotes) query &#x3D; query.set(&quot;includeNotes&quot;, &quot;true&quot;);
        return this.http.get(&#x60;${this.baseUrl}/collection-bundles&#x60;, {params: query}).pipe(
            tap(results &#x3D;&gt; logger.log(&quot;retrieved collection bundle&quot;)),
            catchError(this.handleError_continue&lt;any&gt;({})),
            share() //multicast
        );
    }

    //    ___ ___  _    _    ___ ___ _____ ___ ___  _  _      ___ _  _ ___  _____  __       _   ___ ___ ___
    //   / __/ _ \| |  | |  | __/ __|_   _|_ _/ _ \| \| |    |_ _| \| |   \| __\ \/ /      /_\ | _ \_ _/ __|
    //  | (_| (_) | |__| |__| _| (__  | |  | | (_) | .&#x60; |     | || .&#x60; | |) | _| &gt;  &lt;      / _ \|  _/| |\__ \
    //   \___\___/|____|____|___\___| |_| |___\___/|_|\_|    |___|_|\_|___/|___/_/\_\    /_/ \_\_| |___|___/
    //

    /**
     * Post a new collection index to the back-end
     * @param {CollectionIndex} index record to write
     * @returns {Observable&lt;CollectionIndex&gt;} posted index if successful
     */
    public postCollectionIndex(index: CollectionIndex): Observable&lt;CollectionIndex&gt; {
        return this.http.post&lt;CollectionIndex&gt;(&#x60;${this.baseUrl}/collection-indexes&#x60;, index).pipe(
            tap(this.handleSuccess(&quot;collection index added&quot;)),
            map(result &#x3D;&gt; result as CollectionIndex),
            catchError(this.handleError_raise&lt;CollectionIndex&gt;())
        )
    }

    /**
     * Update the given collection index
     * @param {CollectionIndex} index the index to update
     * @param {string} [successMessage&#x3D;&quot;collection index updated&quot;] message to show to the user in the snackbar on success
     * @returns {Observable&lt;CollectionIndex&gt;} the updated record
     */
    public putCollectionIndex(index: CollectionIndex, successMessage: string &#x3D; &quot;collection index updated&quot;): Observable&lt;CollectionIndex&gt; {
        let serialized &#x3D; index.serialize()
        return this.http.put&lt;CollectionIndex&gt;(&#x60;${this.baseUrl}/collection-indexes/${index.collection_index.id}&#x60;, serialized).pipe(
            tap(this.handleSuccess(successMessage)),
            map(result &#x3D;&gt; new CollectionIndex(result)),
            catchError(this.handleError_raise&lt;CollectionIndex&gt;())
        )
    }

    /**
     * Fetch all collection indexes
     * @param {number} limit optional, number to retrieve
     * @param {number} offset optional, number to skip
     * @returns {Observable&lt;CollectionIndex&gt;} collection indexes
     */
    public getCollectionIndexes(limit?: number, offset?: number): Observable&lt;CollectionIndex[]&gt; {
        return this.http.get&lt;CollectionIndex[]&gt;(&#x60;${this.baseUrl}/collection-indexes&#x60;).pipe(
            tap(_ &#x3D;&gt; logger.log(&quot;retrieved collection indexes&quot;)), // on success, trigger the success notification
            map(results &#x3D;&gt; { return results.map(raw &#x3D;&gt; new CollectionIndex(raw)); }),
            catchError(this.handleError_continue&lt;CollectionIndex[]&gt;([])) // on error, trigger the error notification and continue operation without crashing (returns empty item)
        )
    }

    /**
     * Delete the given collection index
     * @param {string} id the ID of the collection index to delete
     */
    public deleteCollectionIndex(id: string): Observable&lt;{}&gt; {
        return this.http.delete(&#x60;${this.baseUrl}/collection-indexes/${id}&#x60;).pipe(
            tap(this.handleSuccess(&quot;collection index removed&quot;)),
            catchError(this.handleError_raise())
        )
    }

    /**
     * Given a URL, retrieve the collection index at the URL
     * @param {string} url the URL of the collection index
     * @returns {Observable&lt;CollectionIndex&gt;} the collection index at the URL
     */
    public getRemoteIndex(url: string): Observable&lt;CollectionIndex&gt; {
        console.log(&quot;get remote index via rest api&quot;)
        let cmBaseUrl &#x3D; environment.integrations.collection_manager.url;
        let params &#x3D; new HttpParams({encoder: new CustomEncoder()}).set(&quot;url&quot;, url);
        let headers: HttpHeaders &#x3D; new HttpHeaders({ &#x27;ExcludeCredentials&#x27;: &#x27;true&#x27; });
        return this.http.get(&#x60;${cmBaseUrl}/collection-indexes/remote&#x60;, {headers: headers, params: params}).pipe(
            tap(_ &#x3D;&gt; logger.log(&quot;downloaded index at&quot;, url)), // on success, trigger the success notification
            map(index &#x3D;&gt; { return {
                &quot;collection_index&quot;: index,
                &quot;workspace&quot;: { remote_url: url }
            } as CollectionIndex }),
            catchError(this.handleError_continue&lt;CollectionIndex&gt;()) // on error, trigger the error notification and continue operation without crashing (returns empty item)
        )
    }

    //   _____   _____ _____ ___ __  __    ___ ___  _  _ ___ ___ ___     _   ___ ___ ___
    //  / __\ \ / / __|_   _| __|  \/  |  / __/ _ \| \| | __|_ _/ __|   /_\ | _ \_ _/ __|
    //  \__ \\ V /\__ \ | | | _|| |\/| | | (_| (_) | .&#x60; | _| | | (_ |  / _ \|  _/| |\__ \
    //  |___/ |_| |___/ |_| |___|_|  |_|  \___\___/|_|\_|_| |___\___| /_/ \_\_| |___|___/
    //

    /**
     * Get all allowed values
     * @returns {Observable&lt;any&gt;} all allowed values
     */
    private allowedValues;
    public getAllAllowedValues(): Observable&lt;any&gt; {
        if (this.allowedValues) { return of(this.allowedValues)}

        const data$ &#x3D; this.http.get&lt;any&gt;(&#x60;${this.baseUrl}/config/allowed-values&#x60;).pipe(
            tap(_ &#x3D;&gt; logger.log(&quot;retrieved allowed values&quot;)),
            map(result &#x3D;&gt; result as any),
            catchError(this.handleError_continue&lt;string[]&gt;([]))
        );
        let subscription &#x3D; data$.subscribe({
            next: (data) &#x3D;&gt; { this.allowedValues &#x3D; data; },
            complete: () &#x3D;&gt; { subscription.unsubscribe(); }
        });
        return data$;
    }

    /**
     * Get the default marking definitions
     * @returns {Observable&lt;any&gt;} default marking definitions
     */
     public getDefaultMarkingDefinitions(): Observable&lt;any&gt; {
        return this.http.get(&#x60;${this.baseUrl}/config/default-marking-definitions&#x60;).pipe(
            tap(_ &#x3D;&gt; logger.log(&quot;retrieved default marking definitions&quot;)),
            map(result &#x3D;&gt; {
                return result;
            }),
            catchError(this.handleError_continue&lt;string[]&gt;())
        )
    }

    /**
     * Set the default marking definitions
     * @returns {Observable&lt;any&gt;} default marking definitions
     */
    public postDefaultMarkingDefinitions(defaultMarkingDefs: string[]): Observable&lt;any&gt; {
        return this.http.post(&#x60;${this.baseUrl}/config/default-marking-definitions&#x60;, defaultMarkingDefs).pipe(
            tap(this.handleSuccess(&#x60;saved default marking definitions&#x60;)),
            catchError(this.handleError_raise&lt;string[]&gt;()),
            share() //multicast to subscribers
        )
    }

    /**
     * Get the organization identity
     * @returns {Observable&lt;Identity&gt;} the organization identity
     */
     public getOrganizationIdentity(): Observable&lt;Identity&gt; {
        return this.http.get(&#x60;${this.baseUrl}/config/organization-identity&#x60;).pipe(
            tap(_ &#x3D;&gt; logger.log(&quot;retrieved organization identity&quot;)),
            map(result &#x3D;&gt; {
                return new Identity(result);
            }),
            catchError(this.handleError_continue&lt;Identity&gt;()),
            share() //multicast to subscribers
        )
    }

    /**
     * Update the organization identity
     * @param {Identity} object the identity object to save
     * @returns {Observable&lt;Identity&gt;} the updated identity
     * @memberof RestApiConnectorService
     */
    public setOrganizationIdentity(object: Identity):  Observable&lt;Identity&gt; {
        return this.postIdentity(object).pipe( //create/save the identity
            switchMap((result) &#x3D;&gt; {
                logger.log(result);
                // set the organization identity to be this identity&#x27;s ID after it was created/updated
                return this.http.post(&#x60;${this.baseUrl}/config/organization-identity&#x60;, {id: result.stixID}).pipe(
                    tap(this.handleSuccess(&quot;Organization Identity Updated&quot;)),
                    map(_ &#x3D;&gt; {
                        return new Identity(result);
                    }),
                    catchError(this.handleError_raise&lt;Identity&gt;()),
                    share() // multicast so that multiple subscribers don&#x27;t trigger the call twice. THIS MUST BE THE LAST LINE OF THE PIPE
                )
            })
        )
    }

    /**
     * Get the organization namespace configurations
     * @returns {Observable&lt;Namespace&gt;} the organization namespace configurations
     */
    public getOrganizationNamespace(): Observable&lt;Namespace&gt; {
        return this.http.get(&#x60;${this.baseUrl}/config/organization-namespace&#x60;).pipe(
            tap(_ &#x3D;&gt; logger.log(&quot;retrieved organization namespace configurations&quot;)),
            map(result &#x3D;&gt; {
                return result;
            }),
            catchError(this.handleError_continue&lt;any&gt;()),
            share() //multicast to subscribers
        )
    }

    /**
     * Update the organization namespace config
     * @returns {Observable&lt;Namespace&gt;} the updated identity
     * @memberof RestApiConnectorService
     * @param namespaceSettings the namespace object to save
     */
    public setOrganizationNamespace(namespaceSettings: Namespace):  Observable&lt;Namespace&gt; {
        const range &#x3D; namespaceSettings.range_start ? Number(namespaceSettings.range_start) : 0;
        return this.http.post(&#x60;${this.baseUrl}/config/organization-namespace&#x60;, {...namespaceSettings, range_start: range}).pipe(
            // set the organization identity to be this identity&#x27;s ID after it was created/updated
            tap(this.handleSuccess(&quot;Organization Namespace Updated&quot;)),
            map(_ &#x3D;&gt; {
                return namespaceSettings;
            }),
            catchError(this.handleError_raise&lt;any&gt;()),
            share() // multicast so that multiple subscribers don&#x27;t trigger the call twice. THIS MUST BE THE LAST LINE OF THE PIPE
        );
    }

    //   _   _ ___ ___ ___     _   ___ ___ ___  _   _ _  _ _____     _   ___ ___ ___
    //  | | | / __| __| _ \   /_\ / __/ __/ _ \| | | | \| |_   _|   /_\ | _ \_ _/ __|
    //  | |_| \__ \ _||   /  / _ \ (_| (_| (_) | |_| | .&#x60; | | |    / _ \|  _/| |\__ \
    //   \___/|___/___|_|_\ /_/ \_\___\___\___/ \___/|_|\_| |_|   /_/ \_\_| |___|___/

    /**
     * Get all user accounts
     * @param {number} [limit] the number of user accounts to retrieve
     * @param {number} [offset] the number of user accounts to skip
     * @param {string[]} [status] if specified, only get objects with this status
     * @param {string[]} [role] if specified, only get objects with this role
     * @param {string} [search] Only return user accounts where the provided search text occurs in the username or email. The search is case-insensitive.
     * @returns {Observable&lt;Paginated&gt;} paginated data of the user accounts
     */
    public getAllUserAccounts(options?: {limit?: number, offset?: number, status?: string[], role?: string[], search?: string}): Observable&lt;Paginated&lt;UserAccount&gt;&gt; {
        let url &#x3D; &#x60;${this.baseUrl}/user-accounts&#x60;;
        // parse params into query string
        let query &#x3D; new HttpParams({encoder: new CustomEncoder()});
        // pagination
        if (options &amp;&amp; options.limit) query &#x3D; query.set(&quot;limit&quot;, options.limit.toString());
        if (options &amp;&amp; options.offset) query &#x3D; query.set(&quot;offset&quot;, options.offset.toString());
        if (options &amp;&amp; (options.limit || options.offset)) query &#x3D; query.set(&quot;includePagination&quot;, &quot;true&quot;);
        // search
        if (options &amp;&amp; options.search) query &#x3D; query.set(&quot;search&quot;, options.search);
        // status/role
        if (options &amp;&amp; options.status) options.status.forEach((status) &#x3D;&gt; query &#x3D; query.append(&quot;status&quot;, status));
        if (options &amp;&amp; options.role) options.role.forEach((role) &#x3D;&gt; query &#x3D; query.append(&quot;role&quot;, role));
        return this.http.get&lt;Paginated&lt;UserAccount&gt;&gt;(url, {params: query}).pipe(
            catchError(this.handleError_continue&lt;Paginated&lt;UserAccount&gt;&gt;({data: [], pagination: {total: 0, limit: 0, offset:0}})),
            share() //multicast to subscribers
        )
    }

    /**
     * GET a single user account by ID
     * @param {string} id the object ID
     * @returns {Observable&lt;UserAccount&gt;} the object with the given ID
     */
    public getUserAccount(id: string): Observable&lt;UserAccount&gt; {
        let url &#x3D; &#x60;${this.baseUrl}/user-accounts/${id}&#x60;;
        return this.http.get&lt;UserAccount&gt;(url).pipe(
            catchError(this.handleError_continue&lt;UserAccount&gt;()),
            share() // multicast to subscribers
        )
    }

    /**
     * POST (create) a new user account
     * @param {UserAccount} userAccount the object to create
     * @returns {Observable&lt;UserAccount&gt;} the created object
     */
    public postUserAccount(userAccount: UserAccount): Observable&lt;UserAccount&gt; {
        let url &#x3D; &#x60;${this.baseUrl}/user-accounts/${userAccount.id}&#x60;;
        return this.http.post&lt;UserAccount&gt;(url, userAccount).pipe(
            catchError(this.handleError_raise&lt;UserAccount&gt;()),
            share() // multicast to subscribers
        )
    }

    /**
     * PUT (update) a user account
     * @param {UserAccount} userAccount the object to update
     * @returns {Observable&lt;UserAccount&gt;} the updated object
     */
    public putUserAccount(userAccount: UserAccount): Observable&lt;UserAccount&gt; {
        let url &#x3D; &#x60;${this.baseUrl}/user-accounts/${userAccount.id}&#x60;;
        return this.http.put&lt;UserAccount&gt;(url, userAccount).pipe(
            catchError(this.handleError_raise&lt;UserAccount&gt;()),
            share() // multicast to subscribers
        )
    }

    //   ___    ___      __  ___ _____ _____  __    _   ___ ___ ___
    //  | _ \  /_\ \    / / / __|_   _|_ _\ \/ /   /_\ | _ \_ _/ __|
    //  |   / / _ \ \/\/ /  \__ \ | |  | | &gt;  &lt;   / _ \|  _/| |\__ \
    //  |_|_\/_/ \_\_/\_/   |___/ |_| |___/_/\_\ /_/ \_\_| |___|___/

    /**
     * Helper function: trigger the download of the given data from the browser
     * @param data: the data to download. Must be a JSON
     * @param filename: the name of the file to download
     */
     public triggerBrowserDownload(data: any, filename: string) {
        let url &#x3D; URL.createObjectURL(new Blob([JSON.stringify(data, null, 4)], {type: &quot;text/json&quot;}));
        let downloadLink &#x3D; document.createElement(&quot;a&quot;);
        downloadLink.href &#x3D; url;
        downloadLink.download &#x3D; filename
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);
    }

    /**
     * Get a stix bundle by domain
     * @param {string} domain the domain to fetch
     * @returns {Observable&lt;any&gt;} the raw STIX bundle of the domain
     */
    public getStixBundle(domain: string): Observable&lt;any&gt; {
        let query &#x3D; new HttpParams();
        query &#x3D; query.set(&quot;domain&quot;, domain);
        return this.http.get(&#x60;${this.baseUrl}/stix-bundles&#x60;, {params: query}).pipe(
            tap(results &#x3D;&gt; logger.log(&quot;retrieved stix bundle&quot;)),
            catchError(this.handleError_continue&lt;any&gt;({})),
            share() //multicast
        );
    }

    /**
     * Download a stix bundle by domain. Triggers browser download UI when complete.
     * @param {string} domain the domain to download
     * @param filename: the name of the file to download
     * @returns {Observable&lt;any&gt;} the observable to watch while download is loading
     */
    public downloadStixBundle(domain: string, filename: string): Observable&lt;any&gt; {
        let getter &#x3D; this.getStixBundle(domain);
        let subscription &#x3D; getter.subscribe({
            next: (result) &#x3D;&gt; {
                this.triggerBrowserDownload(result, filename)
            },
            complete: () &#x3D;&gt; { subscription.unsubscribe(); }
        });
        return getter;
    }

    /**
     * Download a collection bundle. Triggers browser download UI when complete.
     * @param {string} id the STIX ID of the collection
     * @param {Date} modified the modified date of the collection
     * @param {string} filename the name of the file to download
     * @param {boolean} includeNotes if true, include relevant Note objects
     * @returns {Observable&lt;any&gt;} the observable to watch while download is loading
     */
     public downloadCollectionBundle(id: string, modified: Date, filename: string, includeNotes?: boolean): Observable&lt;any&gt; {
        let getter &#x3D; this.getCollectionBundle(id, modified, includeNotes);
        let subscription &#x3D; getter.subscribe({
            next: (result) &#x3D;&gt; {
                logger.log(result);
                this.triggerBrowserDownload(result, filename)
            },
            complete: () &#x3D;&gt; { subscription.unsubscribe(); }
        });
        return getter;
    }
}

class CustomEncoder implements HttpParameterCodec {
    encodeKey(key: string): string {
        return encodeURIComponent(key);
    }
    encodeValue(value: string): string {
        return encodeURIComponent(value);
    }
    decodeKey(key: string): string {
        return decodeURIComponent(key);
    }
    decodeValue(value: string): string {
        return decodeURIComponent(value);
    }
}
</code></pre>
    </div>
</div>









                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'class';
            var COMPODOC_CURRENT_PAGE_URL = 'CustomEncoder.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>

       <script src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
